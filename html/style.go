// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"slices"
	"strings"

	"github.com/derekmwright/htemel"
	"golang.org/x/net/html"
)

type StyleElement struct {
	attributes styleAttrs
	children   []htemel.Node
	skipRender bool
}

// Style creates a tag <style> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The style element allows authors to embed CSS style sheets in their documents. The style element is one of several inputs to the styling processing model. The element does not represent content for the user.
func Style(children ...htemel.Node) *StyleElement {
	node := &StyleElement{
		children:   children,
		attributes: make(styleAttrs),
	}

	return node
}

func StyleIf(condition bool, children ...htemel.Node) *StyleElement {
	if condition {
		return Style(children...)
	}

	return &StyleElement{
		children:   children,
		attributes: make(styleAttrs),
		skipRender: true,
	}
}

func StyleTernary(condition bool, true htemel.Node, false htemel.Node) *StyleElement {
	if condition {
		return Style(true)
	}
	return Style(false)
}

// Children appends children to this element.
func (e *StyleElement) Children(children ...htemel.Node) *StyleElement {
	e.children = append(e.children, children...)
	return e
}

// With allows passing a function to modify the element via a closure.
func (e *StyleElement) With(fn func(*StyleElement)) *StyleElement {
	fn(e)
	return e
}

// Text adds a text node to the element.
func (e *StyleElement) Text(text string) *StyleElement {
	return e.Children(htemel.Text(text))
}

// Textf adds a text node to the element with the given format string and arguments.
func (e *StyleElement) Textf(format string, args ...any) *StyleElement {
	return e.Children(htemel.Text(fmt.Sprintf(format, args...)))
}

// If conditionally adds a child node to the element if the condition is true, otherwise it is a no-op.
func (e *StyleElement) If(cond bool, child htemel.Node) *StyleElement {
	if cond {
		return e.Children(child)
	}
	return e
}

func (e *StyleElement) IfElse(cond bool, then, els htemel.Node) *StyleElement {
	if cond {
		e.Children(then)
	} else {
		e.Children(els)
	}
	return e
}

// IfThen conditionally calls the given function with the element if the condition is true, otherwise it is a no-op.
func (e *StyleElement) IfThen(cond bool, fn func(*StyleElement)) *StyleElement {
	if cond {
		fn(e)
	}
	return e
}

// AddClass appends a class to the element.
func (e *StyleElement) AddClass(classes ...string) *StyleElement {
	current := e.attributes["class"].(string)
	all := append(strings.Fields(current), classes...)
	e.attributes["class"] = strings.Join(all, " ")
	return e
}

// ToggleClass toggles a class on or off.
func (e *StyleElement) ToggleClass(class string, enable bool) *StyleElement {
	classes := strings.Fields(e.attributes["class"].(string))
	idx := slices.Index(classes, class)
	if enable && idx == -1 {
		classes = append(classes, class)
	} else if !enable && idx >= 0 {
		classes = slices.Delete(classes, idx, idx+1)
	}
	e.attributes["class"] = strings.Join(classes, " ")
	return e
}

type StyleAutocapitalize string

const (
	StyleAutocapitalizeCharacters StyleAutocapitalize = "characters"
	StyleAutocapitalizeNone       StyleAutocapitalize = "none"
	StyleAutocapitalizeOff        StyleAutocapitalize = "off"
	StyleAutocapitalizeOn         StyleAutocapitalize = "on"
	StyleAutocapitalizeSentences  StyleAutocapitalize = "sentences"
	StyleAutocapitalizeWords      StyleAutocapitalize = "words"
)

type StyleAutocorrect string

const (
	StyleAutocorrectOff   StyleAutocorrect = "off"
	StyleAutocorrectOn    StyleAutocorrect = "on"
	StyleAutocorrectEmpty StyleAutocorrect = ""
)

type StyleContenteditable string

const (
	StyleContenteditableFalse         StyleContenteditable = "false"
	StyleContenteditablePlaintextOnly StyleContenteditable = "plaintext-only"
	StyleContenteditableTrue          StyleContenteditable = "true"
	StyleContenteditableEmpty         StyleContenteditable = ""
)

type StyleDir string

const (
	StyleDirAuto StyleDir = "auto"
	StyleDirLtr  StyleDir = "ltr"
	StyleDirRtl  StyleDir = "rtl"
)

type StyleDraggable string

const (
	StyleDraggableTrue  StyleDraggable = "true"
	StyleDraggableFalse StyleDraggable = "false"
)

type StyleEnterkeyhint string

const (
	StyleEnterkeyhintGo       StyleEnterkeyhint = "go"
	StyleEnterkeyhintNext     StyleEnterkeyhint = "next"
	StyleEnterkeyhintPrevious StyleEnterkeyhint = "previous"
	StyleEnterkeyhintSearch   StyleEnterkeyhint = "search"
	StyleEnterkeyhintSend     StyleEnterkeyhint = "send"
	StyleEnterkeyhintDone     StyleEnterkeyhint = "done"
	StyleEnterkeyhintEnter    StyleEnterkeyhint = "enter"
)

type StyleHidden string

const (
	StyleHiddenHidden     StyleHidden = "hidden"
	StyleHiddenUntilFound StyleHidden = "until-found"
	StyleHiddenEmpty      StyleHidden = ""
)

type StyleInputmode string

const (
	StyleInputmodeTel     StyleInputmode = "tel"
	StyleInputmodeText    StyleInputmode = "text"
	StyleInputmodeUrl     StyleInputmode = "url"
	StyleInputmodeDecimal StyleInputmode = "decimal"
	StyleInputmodeEmail   StyleInputmode = "email"
	StyleInputmodeNone    StyleInputmode = "none"
	StyleInputmodeNumeric StyleInputmode = "numeric"
	StyleInputmodeSearch  StyleInputmode = "search"
)

type StyleSpellcheck string

const (
	StyleSpellcheckFalse StyleSpellcheck = "false"
	StyleSpellcheckTrue  StyleSpellcheck = "true"
	StyleSpellcheckEmpty StyleSpellcheck = ""
)

type StyleTranslate string

const (
	StyleTranslateNo    StyleTranslate = "no"
	StyleTranslateYes   StyleTranslate = "yes"
	StyleTranslateEmpty StyleTranslate = ""
)

type StyleWritingsuggestions string

const (
	StyleWritingsuggestionsFalse StyleWritingsuggestions = "false"
	StyleWritingsuggestionsTrue  StyleWritingsuggestions = "true"
	StyleWritingsuggestionsEmpty StyleWritingsuggestions = ""
)

type styleAttrs map[string]any

func (e *StyleElement) Media(s string) *StyleElement {
	e.attributes["media"] = s

	return e
}

func (e *StyleElement) Blocking(s string) *StyleElement {
	e.attributes["blocking"] = s

	return e
}

func (e *StyleElement) AriaUnsafe(name string, s string) *StyleElement {
	tag := strings.ToLower("aria-" + name)

	e.attributes[tag] = s

	return e
}

func (e *StyleElement) Aria(name string, s string) *StyleElement {
	return e.AriaUnsafe(name, html.EscapeString(s))
}

func (e *StyleElement) Autocapitalize(a StyleAutocapitalize) *StyleElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *StyleElement) Autocorrect(a StyleAutocorrect) *StyleElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *StyleElement) Autofocus(b bool) *StyleElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *StyleElement) Class(s ...string) *StyleElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *StyleElement) Contenteditable(a StyleContenteditable) *StyleElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *StyleElement) DataUnsafe(name string, s string) *StyleElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *StyleElement) Data(name string, s string) *StyleElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *StyleElement) Dir(a StyleDir) *StyleElement {
	e.attributes["dir"] = a

	return e
}

func (e *StyleElement) Draggable(a StyleDraggable) *StyleElement {
	e.attributes["draggable"] = a

	return e
}

func (e *StyleElement) Enterkeyhint(a StyleEnterkeyhint) *StyleElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *StyleElement) Hidden(a StyleHidden) *StyleElement {
	e.attributes["hidden"] = a

	return e
}

func (e *StyleElement) Id(s string) *StyleElement {
	e.attributes["id"] = s

	return e
}

func (e *StyleElement) Inert(b bool) *StyleElement {
	e.attributes["inert"] = b

	return e
}

func (e *StyleElement) Inputmode(a StyleInputmode) *StyleElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *StyleElement) Itemid(s string) *StyleElement {
	e.attributes["itemid"] = s

	return e
}

func (e *StyleElement) Itemprop(s ...string) *StyleElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *StyleElement) Itemref(s ...string) *StyleElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *StyleElement) Itemscope(b bool) *StyleElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *StyleElement) Itemtype(s ...string) *StyleElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *StyleElement) Lang(s string) *StyleElement {
	e.attributes["lang"] = s

	return e
}

func (e *StyleElement) Nonce(s string) *StyleElement {
	e.attributes["nonce"] = s

	return e
}

func (e *StyleElement) Popover(s string) *StyleElement {
	e.attributes["popover"] = s

	return e
}

func (e *StyleElement) Role(s string) *StyleElement {
	e.attributes["role"] = s

	return e
}

func (e *StyleElement) Slot(s string) *StyleElement {
	e.attributes["slot"] = s

	return e
}

func (e *StyleElement) Spellcheck(a StyleSpellcheck) *StyleElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *StyleElement) Style(s string) *StyleElement {
	e.attributes["style"] = s

	return e
}

func (e *StyleElement) Tabindex(i int) *StyleElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *StyleElement) Title(s string) *StyleElement {
	e.attributes["title"] = s

	return e
}

func (e *StyleElement) Translate(a StyleTranslate) *StyleElement {
	e.attributes["translate"] = a

	return e
}

func (e *StyleElement) Writingsuggestions(a StyleWritingsuggestions) *StyleElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *StyleElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	var sb strings.Builder
	sb.WriteString("<style")

	for key, v := range e.attributes {
		sb.WriteByte(' ')
		sb.WriteString(key)

		strVal := fmt.Sprintf("%v", v)
		if strVal != "" {
			sb.WriteByte('=')
			sb.WriteByte('"')
			sb.WriteString(strVal)
			sb.WriteByte('"')
		}
	}

	sb.WriteByte('>')
	for _, child := range e.children {
		if err := child.Render(&sb); err != nil {
			return err
		}
	}

	sb.WriteString("</style>")

	_, err := io.WriteString(w, sb.String())
	return err
}
