// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"slices"
	"strings"

	"github.com/derekmwright/htemel"
	"golang.org/x/net/html"
)

type CiteElement struct {
	attributes citeAttrs
	children   []htemel.Node
	skipRender bool
}

// Cite creates a tag <cite> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The cite element represents the title of a work (e.g. a book, a paper, an essay, a poem, a score, a song, a script, a film, a TV show, a game, a sculpture, a painting, a theatre production, a play, an opera, a musical, an exhibition, a legal case report, a computer program,  etc.). This can be a work that is being quoted or referenced in detail (i.e., a citation), or it can just be a work that is mentioned in passing.
func Cite(children ...htemel.Node) *CiteElement {
	node := &CiteElement{
		children:   children,
		attributes: make(citeAttrs),
	}

	return node
}

func CiteIf(condition bool, children ...htemel.Node) *CiteElement {
	if condition {
		return Cite(children...)
	}

	return &CiteElement{
		children:   children,
		attributes: make(citeAttrs),
		skipRender: true,
	}
}

func CiteTernary(condition bool, true htemel.Node, false htemel.Node) *CiteElement {
	if condition {
		return Cite(true)
	}
	return Cite(false)
}

// Children appends children to this element.
func (e *CiteElement) Children(children ...htemel.Node) *CiteElement {
	e.children = append(e.children, children...)
	return e
}

// With allows passing a function to modify the element via a closure.
func (e *CiteElement) With(fn func(*CiteElement)) *CiteElement {
	fn(e)
	return e
}

// Textf adds a text node to the element with the given format string and arguments.
func (e *CiteElement) Textf(format string, args ...any) *CiteElement {
	return e.Children(htemel.Text(fmt.Sprintf(format, args...)))
}

// AddClass appends a class to the element.
func (e *CiteElement) AddClass(classes ...string) *CiteElement {
	current := e.attributes["class"].(string)
	all := append(strings.Fields(current), classes...)
	e.attributes["class"] = strings.Join(all, " ")
	return e
}

// ToggleClass toggles a class on or off.
func (e *CiteElement) ToggleClass(class string, enable bool) *CiteElement {
	classes := strings.Fields(e.attributes["class"].(string))
	idx := slices.Index(classes, class)
	if enable && idx == -1 {
		classes = append(classes, class)
	} else if !enable && idx >= 0 {
		classes = slices.Delete(classes, idx, idx+1)
	}
	e.attributes["class"] = strings.Join(classes, " ")
	return e
}

type CiteAutocapitalize string

const (
	CiteAutocapitalizeWords      CiteAutocapitalize = "words"
	CiteAutocapitalizeCharacters CiteAutocapitalize = "characters"
	CiteAutocapitalizeNone       CiteAutocapitalize = "none"
	CiteAutocapitalizeOff        CiteAutocapitalize = "off"
	CiteAutocapitalizeOn         CiteAutocapitalize = "on"
	CiteAutocapitalizeSentences  CiteAutocapitalize = "sentences"
)

type CiteAutocorrect string

const (
	CiteAutocorrectOff   CiteAutocorrect = "off"
	CiteAutocorrectOn    CiteAutocorrect = "on"
	CiteAutocorrectEmpty CiteAutocorrect = ""
)

type CiteContenteditable string

const (
	CiteContenteditableTrue          CiteContenteditable = "true"
	CiteContenteditableFalse         CiteContenteditable = "false"
	CiteContenteditablePlaintextOnly CiteContenteditable = "plaintext-only"
	CiteContenteditableEmpty         CiteContenteditable = ""
)

type CiteDir string

const (
	CiteDirAuto CiteDir = "auto"
	CiteDirLtr  CiteDir = "ltr"
	CiteDirRtl  CiteDir = "rtl"
)

type CiteDraggable string

const (
	CiteDraggableFalse CiteDraggable = "false"
	CiteDraggableTrue  CiteDraggable = "true"
)

type CiteEnterkeyhint string

const (
	CiteEnterkeyhintSearch   CiteEnterkeyhint = "search"
	CiteEnterkeyhintSend     CiteEnterkeyhint = "send"
	CiteEnterkeyhintDone     CiteEnterkeyhint = "done"
	CiteEnterkeyhintEnter    CiteEnterkeyhint = "enter"
	CiteEnterkeyhintGo       CiteEnterkeyhint = "go"
	CiteEnterkeyhintNext     CiteEnterkeyhint = "next"
	CiteEnterkeyhintPrevious CiteEnterkeyhint = "previous"
)

type CiteHidden string

const (
	CiteHiddenUntilFound CiteHidden = "until-found"
	CiteHiddenHidden     CiteHidden = "hidden"
	CiteHiddenEmpty      CiteHidden = ""
)

type CiteInputmode string

const (
	CiteInputmodeSearch  CiteInputmode = "search"
	CiteInputmodeTel     CiteInputmode = "tel"
	CiteInputmodeText    CiteInputmode = "text"
	CiteInputmodeUrl     CiteInputmode = "url"
	CiteInputmodeDecimal CiteInputmode = "decimal"
	CiteInputmodeEmail   CiteInputmode = "email"
	CiteInputmodeNone    CiteInputmode = "none"
	CiteInputmodeNumeric CiteInputmode = "numeric"
)

type CiteSpellcheck string

const (
	CiteSpellcheckFalse CiteSpellcheck = "false"
	CiteSpellcheckTrue  CiteSpellcheck = "true"
	CiteSpellcheckEmpty CiteSpellcheck = ""
)

type CiteTranslate string

const (
	CiteTranslateNo    CiteTranslate = "no"
	CiteTranslateYes   CiteTranslate = "yes"
	CiteTranslateEmpty CiteTranslate = ""
)

type CiteWritingsuggestions string

const (
	CiteWritingsuggestionsFalse CiteWritingsuggestions = "false"
	CiteWritingsuggestionsTrue  CiteWritingsuggestions = "true"
	CiteWritingsuggestionsEmpty CiteWritingsuggestions = ""
)

type citeAttrs map[string]any

func (e *CiteElement) AriaUnsafe(name string, s string) *CiteElement {
	tag := strings.ToLower("aria-" + name)

	e.attributes[tag] = s

	return e
}

func (e *CiteElement) Aria(name string, s string) *CiteElement {
	return e.AriaUnsafe(name, html.EscapeString(s))
}

func (e *CiteElement) Autocapitalize(a CiteAutocapitalize) *CiteElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *CiteElement) Autocorrect(a CiteAutocorrect) *CiteElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *CiteElement) Autofocus(b bool) *CiteElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *CiteElement) Class(s ...string) *CiteElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *CiteElement) Contenteditable(a CiteContenteditable) *CiteElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *CiteElement) DataUnsafe(name string, s string) *CiteElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *CiteElement) Data(name string, s string) *CiteElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *CiteElement) Dir(a CiteDir) *CiteElement {
	e.attributes["dir"] = a

	return e
}

func (e *CiteElement) Draggable(a CiteDraggable) *CiteElement {
	e.attributes["draggable"] = a

	return e
}

func (e *CiteElement) Enterkeyhint(a CiteEnterkeyhint) *CiteElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *CiteElement) Hidden(a CiteHidden) *CiteElement {
	e.attributes["hidden"] = a

	return e
}

func (e *CiteElement) Id(s string) *CiteElement {
	e.attributes["id"] = s

	return e
}

func (e *CiteElement) Inert(b bool) *CiteElement {
	e.attributes["inert"] = b

	return e
}

func (e *CiteElement) Inputmode(a CiteInputmode) *CiteElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *CiteElement) Itemid(s string) *CiteElement {
	e.attributes["itemid"] = s

	return e
}

func (e *CiteElement) Itemprop(s ...string) *CiteElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *CiteElement) Itemref(s ...string) *CiteElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *CiteElement) Itemscope(b bool) *CiteElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *CiteElement) Itemtype(s ...string) *CiteElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *CiteElement) Lang(s string) *CiteElement {
	e.attributes["lang"] = s

	return e
}

func (e *CiteElement) Nonce(s string) *CiteElement {
	e.attributes["nonce"] = s

	return e
}

func (e *CiteElement) Popover(s string) *CiteElement {
	e.attributes["popover"] = s

	return e
}

func (e *CiteElement) Role(s string) *CiteElement {
	e.attributes["role"] = s

	return e
}

func (e *CiteElement) Slot(s string) *CiteElement {
	e.attributes["slot"] = s

	return e
}

func (e *CiteElement) Spellcheck(a CiteSpellcheck) *CiteElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *CiteElement) Style(s string) *CiteElement {
	e.attributes["style"] = s

	return e
}

func (e *CiteElement) Tabindex(i int) *CiteElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *CiteElement) Title(s string) *CiteElement {
	e.attributes["title"] = s

	return e
}

func (e *CiteElement) Translate(a CiteTranslate) *CiteElement {
	e.attributes["translate"] = a

	return e
}

func (e *CiteElement) Writingsuggestions(a CiteWritingsuggestions) *CiteElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *CiteElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<cite")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key))

		// Enum types support empty attributes and can be omitted.
		if fmt.Sprintf("%s", v) == "" {
			w.Write([]byte(" "))
			continue
		}

		w.Write([]byte("="))

		w.Write([]byte("\"" + fmt.Sprintf("%v", v) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}
	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</cite>")); err != nil {
		return err
	}

	return nil
}
