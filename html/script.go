// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"strings"

	"github.com/derekmwright/htemel"
	"golang.org/x/net/html"
)

type ScriptElement struct {
	attributes scriptAttrs
	children   []htemel.Node
	skipRender bool
}

// Script creates a tag <script> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The script element allows authors to include dynamic script, instructions to the user agent, and data blocks in their documents. The element does not represent content for the user.
func Script(children ...htemel.Node) *ScriptElement {
	node := &ScriptElement{
		children:   children,
		attributes: make(scriptAttrs),
	}

	return node
}

func ScriptIf(condition bool, children ...htemel.Node) *ScriptElement {
	if condition {
		return Script(children...)
	}

	return &ScriptElement{
		children:   children,
		attributes: make(scriptAttrs),
		skipRender: true,
	}
}

func ScriptTernary(condition bool, true htemel.Node, false htemel.Node) *ScriptElement {
	if condition {
		return Script(true)
	}

	return Script(false)
}

// Children appends children to this element.
func (e *ScriptElement) Children(children ...htemel.Node) *ScriptElement {
	e.children = append(e.children, children...)

	return e
}

type ScriptBlocking string

const (
	ScriptBlockingRender ScriptBlocking = "render"
)

type ScriptCrossorigin string

const (
	ScriptCrossoriginAnonymous      ScriptCrossorigin = "anonymous"
	ScriptCrossoriginUseCredentials ScriptCrossorigin = "use-credentials"
	ScriptCrossoriginEmpty          ScriptCrossorigin = ""
)

type ScriptFetchpriority string

const (
	ScriptFetchpriorityHigh ScriptFetchpriority = "high"
	ScriptFetchpriorityLow  ScriptFetchpriority = "low"
	ScriptFetchpriorityAuto ScriptFetchpriority = "auto"
)

type ScriptAutocapitalize string

const (
	ScriptAutocapitalizeOff        ScriptAutocapitalize = "off"
	ScriptAutocapitalizeOn         ScriptAutocapitalize = "on"
	ScriptAutocapitalizeSentences  ScriptAutocapitalize = "sentences"
	ScriptAutocapitalizeWords      ScriptAutocapitalize = "words"
	ScriptAutocapitalizeCharacters ScriptAutocapitalize = "characters"
	ScriptAutocapitalizeNone       ScriptAutocapitalize = "none"
)

type ScriptAutocorrect string

const (
	ScriptAutocorrectOff   ScriptAutocorrect = "off"
	ScriptAutocorrectOn    ScriptAutocorrect = "on"
	ScriptAutocorrectEmpty ScriptAutocorrect = ""
)

type ScriptContenteditable string

const (
	ScriptContenteditableFalse         ScriptContenteditable = "false"
	ScriptContenteditablePlaintextOnly ScriptContenteditable = "plaintext-only"
	ScriptContenteditableTrue          ScriptContenteditable = "true"
	ScriptContenteditableEmpty         ScriptContenteditable = ""
)

type ScriptDir string

const (
	ScriptDirRtl  ScriptDir = "rtl"
	ScriptDirAuto ScriptDir = "auto"
	ScriptDirLtr  ScriptDir = "ltr"
)

type ScriptDraggable string

const (
	ScriptDraggableTrue  ScriptDraggable = "true"
	ScriptDraggableFalse ScriptDraggable = "false"
)

type ScriptEnterkeyhint string

const (
	ScriptEnterkeyhintSend     ScriptEnterkeyhint = "send"
	ScriptEnterkeyhintDone     ScriptEnterkeyhint = "done"
	ScriptEnterkeyhintEnter    ScriptEnterkeyhint = "enter"
	ScriptEnterkeyhintGo       ScriptEnterkeyhint = "go"
	ScriptEnterkeyhintNext     ScriptEnterkeyhint = "next"
	ScriptEnterkeyhintPrevious ScriptEnterkeyhint = "previous"
	ScriptEnterkeyhintSearch   ScriptEnterkeyhint = "search"
)

type ScriptHidden string

const (
	ScriptHiddenHidden     ScriptHidden = "hidden"
	ScriptHiddenUntilFound ScriptHidden = "until-found"
	ScriptHiddenEmpty      ScriptHidden = ""
)

type ScriptInputmode string

const (
	ScriptInputmodeTel     ScriptInputmode = "tel"
	ScriptInputmodeText    ScriptInputmode = "text"
	ScriptInputmodeUrl     ScriptInputmode = "url"
	ScriptInputmodeDecimal ScriptInputmode = "decimal"
	ScriptInputmodeEmail   ScriptInputmode = "email"
	ScriptInputmodeNone    ScriptInputmode = "none"
	ScriptInputmodeNumeric ScriptInputmode = "numeric"
	ScriptInputmodeSearch  ScriptInputmode = "search"
)

type ScriptSpellcheck string

const (
	ScriptSpellcheckFalse ScriptSpellcheck = "false"
	ScriptSpellcheckTrue  ScriptSpellcheck = "true"
	ScriptSpellcheckEmpty ScriptSpellcheck = ""
)

type ScriptTranslate string

const (
	ScriptTranslateNo    ScriptTranslate = "no"
	ScriptTranslateYes   ScriptTranslate = "yes"
	ScriptTranslateEmpty ScriptTranslate = ""
)

type ScriptWritingsuggestions string

const (
	ScriptWritingsuggestionsFalse ScriptWritingsuggestions = "false"
	ScriptWritingsuggestionsTrue  ScriptWritingsuggestions = "true"
	ScriptWritingsuggestionsEmpty ScriptWritingsuggestions = ""
)

type scriptAttrs map[string]any

func (e *ScriptElement) Type(s string) *ScriptElement {
	e.attributes["type"] = s

	return e
}

func (e *ScriptElement) Src(s string) *ScriptElement {
	e.attributes["src"] = s

	return e
}

func (e *ScriptElement) Nomodule(b bool) *ScriptElement {
	e.attributes["nomodule"] = b

	return e
}

func (e *ScriptElement) Async(b bool) *ScriptElement {
	e.attributes["async"] = b

	return e
}

func (e *ScriptElement) Defer(b bool) *ScriptElement {
	e.attributes["defer"] = b

	return e
}

func (e *ScriptElement) Blocking(a ScriptBlocking) *ScriptElement {
	e.attributes["blocking"] = a

	return e
}

func (e *ScriptElement) Crossorigin(a ScriptCrossorigin) *ScriptElement {
	e.attributes["crossorigin"] = a

	return e
}

func (e *ScriptElement) Referrerpolicy(s string) *ScriptElement {
	e.attributes["referrerpolicy"] = s

	return e
}

func (e *ScriptElement) Integrity(s string) *ScriptElement {
	e.attributes["integrity"] = s

	return e
}

func (e *ScriptElement) Fetchpriority(a ScriptFetchpriority) *ScriptElement {
	e.attributes["fetchpriority"] = a

	return e
}

func (e *ScriptElement) AriaUnsafe(name string, s string) *ScriptElement {
	tag := strings.ToLower("aria-" + name)

	e.attributes[tag] = s

	return e
}

func (e *ScriptElement) Aria(name string, s string) *ScriptElement {
	return e.AriaUnsafe(name, html.EscapeString(s))
}

func (e *ScriptElement) Autocapitalize(a ScriptAutocapitalize) *ScriptElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *ScriptElement) Autocorrect(a ScriptAutocorrect) *ScriptElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *ScriptElement) Autofocus(b bool) *ScriptElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *ScriptElement) Class(s ...string) *ScriptElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *ScriptElement) Contenteditable(a ScriptContenteditable) *ScriptElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *ScriptElement) DataUnsafe(name string, s string) *ScriptElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *ScriptElement) Data(name string, s string) *ScriptElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *ScriptElement) Dir(a ScriptDir) *ScriptElement {
	e.attributes["dir"] = a

	return e
}

func (e *ScriptElement) Draggable(a ScriptDraggable) *ScriptElement {
	e.attributes["draggable"] = a

	return e
}

func (e *ScriptElement) Enterkeyhint(a ScriptEnterkeyhint) *ScriptElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *ScriptElement) Hidden(a ScriptHidden) *ScriptElement {
	e.attributes["hidden"] = a

	return e
}

func (e *ScriptElement) Id(s string) *ScriptElement {
	e.attributes["id"] = s

	return e
}

func (e *ScriptElement) Inert(b bool) *ScriptElement {
	e.attributes["inert"] = b

	return e
}

func (e *ScriptElement) Inputmode(a ScriptInputmode) *ScriptElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *ScriptElement) Itemid(s string) *ScriptElement {
	e.attributes["itemid"] = s

	return e
}

func (e *ScriptElement) Itemprop(s ...string) *ScriptElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *ScriptElement) Itemref(s ...string) *ScriptElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *ScriptElement) Itemscope(b bool) *ScriptElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *ScriptElement) Itemtype(s ...string) *ScriptElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *ScriptElement) Lang(s string) *ScriptElement {
	e.attributes["lang"] = s

	return e
}

func (e *ScriptElement) Nonce(s string) *ScriptElement {
	e.attributes["nonce"] = s

	return e
}

func (e *ScriptElement) Popover(s string) *ScriptElement {
	e.attributes["popover"] = s

	return e
}

func (e *ScriptElement) Role(s string) *ScriptElement {
	e.attributes["role"] = s

	return e
}

func (e *ScriptElement) Slot(s string) *ScriptElement {
	e.attributes["slot"] = s

	return e
}

func (e *ScriptElement) Spellcheck(a ScriptSpellcheck) *ScriptElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *ScriptElement) Style(s string) *ScriptElement {
	e.attributes["style"] = s

	return e
}

func (e *ScriptElement) Tabindex(i int) *ScriptElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *ScriptElement) Title(s string) *ScriptElement {
	e.attributes["title"] = s

	return e
}

func (e *ScriptElement) Translate(a ScriptTranslate) *ScriptElement {
	e.attributes["translate"] = a

	return e
}

func (e *ScriptElement) Writingsuggestions(a ScriptWritingsuggestions) *ScriptElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *ScriptElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<script")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key))

		// Enum types support empty attributes and can be omitted.
		if fmt.Sprintf("%s", v) == "" {
			w.Write([]byte(" "))
			continue
		}

		w.Write([]byte("="))

		w.Write([]byte("\"" + fmt.Sprintf("%v", v) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}
	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</script>")); err != nil {
		return err
	}

	return nil
}
