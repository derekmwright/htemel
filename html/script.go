// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"slices"
	"strings"

	"github.com/derekmwright/htemel"
	"golang.org/x/net/html"
)

type ScriptElement struct {
	attributes scriptAttrs
	children   []htemel.Node
	skipRender bool
}

// Script creates a tag <script> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The script element allows authors to include dynamic script, instructions to the user agent, and data blocks in their documents. The element does not represent content for the user.
func Script(children ...htemel.Node) *ScriptElement {
	node := &ScriptElement{
		children:   children,
		attributes: make(scriptAttrs),
	}

	return node
}

func ScriptIf(condition bool, children ...htemel.Node) *ScriptElement {
	if condition {
		return Script(children...)
	}

	return &ScriptElement{
		children:   children,
		attributes: make(scriptAttrs),
		skipRender: true,
	}
}

func ScriptTernary(condition bool, true htemel.Node, false htemel.Node) *ScriptElement {
	if condition {
		return Script(true)
	}
	return Script(false)
}

// Children appends children to this element.
func (e *ScriptElement) Children(children ...htemel.Node) *ScriptElement {
	e.children = append(e.children, children...)
	return e
}

// With allows passing a function to modify the element via a closure.
func (e *ScriptElement) With(fn func(*ScriptElement)) *ScriptElement {
	fn(e)
	return e
}

// Text adds a text node to the element.
func (e *ScriptElement) Text(text string) *ScriptElement {
	return e.Children(htemel.Text(text))
}

// Textf adds a text node to the element with the given format string and arguments.
func (e *ScriptElement) Textf(format string, args ...any) *ScriptElement {
	return e.Children(htemel.Text(fmt.Sprintf(format, args...)))
}

// AddClass appends a class to the element.
func (e *ScriptElement) AddClass(classes ...string) *ScriptElement {
	current := e.attributes["class"].(string)
	all := append(strings.Fields(current), classes...)
	e.attributes["class"] = strings.Join(all, " ")
	return e
}

// ToggleClass toggles a class on or off.
func (e *ScriptElement) ToggleClass(class string, enable bool) *ScriptElement {
	classes := strings.Fields(e.attributes["class"].(string))
	idx := slices.Index(classes, class)
	if enable && idx == -1 {
		classes = append(classes, class)
	} else if !enable && idx >= 0 {
		classes = slices.Delete(classes, idx, idx+1)
	}
	e.attributes["class"] = strings.Join(classes, " ")
	return e
}

type ScriptBlocking string

const (
	ScriptBlockingRender ScriptBlocking = "render"
)

type ScriptCrossorigin string

const (
	ScriptCrossoriginAnonymous      ScriptCrossorigin = "anonymous"
	ScriptCrossoriginUseCredentials ScriptCrossorigin = "use-credentials"
	ScriptCrossoriginEmpty          ScriptCrossorigin = ""
)

type ScriptFetchpriority string

const (
	ScriptFetchpriorityLow  ScriptFetchpriority = "low"
	ScriptFetchpriorityAuto ScriptFetchpriority = "auto"
	ScriptFetchpriorityHigh ScriptFetchpriority = "high"
)

type ScriptAutocapitalize string

const (
	ScriptAutocapitalizeCharacters ScriptAutocapitalize = "characters"
	ScriptAutocapitalizeNone       ScriptAutocapitalize = "none"
	ScriptAutocapitalizeOff        ScriptAutocapitalize = "off"
	ScriptAutocapitalizeOn         ScriptAutocapitalize = "on"
	ScriptAutocapitalizeSentences  ScriptAutocapitalize = "sentences"
	ScriptAutocapitalizeWords      ScriptAutocapitalize = "words"
)

type ScriptAutocorrect string

const (
	ScriptAutocorrectOff   ScriptAutocorrect = "off"
	ScriptAutocorrectOn    ScriptAutocorrect = "on"
	ScriptAutocorrectEmpty ScriptAutocorrect = ""
)

type ScriptContenteditable string

const (
	ScriptContenteditableFalse         ScriptContenteditable = "false"
	ScriptContenteditablePlaintextOnly ScriptContenteditable = "plaintext-only"
	ScriptContenteditableTrue          ScriptContenteditable = "true"
	ScriptContenteditableEmpty         ScriptContenteditable = ""
)

type ScriptDir string

const (
	ScriptDirAuto ScriptDir = "auto"
	ScriptDirLtr  ScriptDir = "ltr"
	ScriptDirRtl  ScriptDir = "rtl"
)

type ScriptDraggable string

const (
	ScriptDraggableFalse ScriptDraggable = "false"
	ScriptDraggableTrue  ScriptDraggable = "true"
)

type ScriptEnterkeyhint string

const (
	ScriptEnterkeyhintSend     ScriptEnterkeyhint = "send"
	ScriptEnterkeyhintDone     ScriptEnterkeyhint = "done"
	ScriptEnterkeyhintEnter    ScriptEnterkeyhint = "enter"
	ScriptEnterkeyhintGo       ScriptEnterkeyhint = "go"
	ScriptEnterkeyhintNext     ScriptEnterkeyhint = "next"
	ScriptEnterkeyhintPrevious ScriptEnterkeyhint = "previous"
	ScriptEnterkeyhintSearch   ScriptEnterkeyhint = "search"
)

type ScriptHidden string

const (
	ScriptHiddenHidden     ScriptHidden = "hidden"
	ScriptHiddenUntilFound ScriptHidden = "until-found"
	ScriptHiddenEmpty      ScriptHidden = ""
)

type ScriptInputmode string

const (
	ScriptInputmodeNumeric ScriptInputmode = "numeric"
	ScriptInputmodeSearch  ScriptInputmode = "search"
	ScriptInputmodeTel     ScriptInputmode = "tel"
	ScriptInputmodeText    ScriptInputmode = "text"
	ScriptInputmodeUrl     ScriptInputmode = "url"
	ScriptInputmodeDecimal ScriptInputmode = "decimal"
	ScriptInputmodeEmail   ScriptInputmode = "email"
	ScriptInputmodeNone    ScriptInputmode = "none"
)

type ScriptSpellcheck string

const (
	ScriptSpellcheckFalse ScriptSpellcheck = "false"
	ScriptSpellcheckTrue  ScriptSpellcheck = "true"
	ScriptSpellcheckEmpty ScriptSpellcheck = ""
)

type ScriptTranslate string

const (
	ScriptTranslateNo    ScriptTranslate = "no"
	ScriptTranslateYes   ScriptTranslate = "yes"
	ScriptTranslateEmpty ScriptTranslate = ""
)

type ScriptWritingsuggestions string

const (
	ScriptWritingsuggestionsFalse ScriptWritingsuggestions = "false"
	ScriptWritingsuggestionsTrue  ScriptWritingsuggestions = "true"
	ScriptWritingsuggestionsEmpty ScriptWritingsuggestions = ""
)

type scriptAttrs map[string]any

func (e *ScriptElement) Type(s string) *ScriptElement {
	e.attributes["type"] = s

	return e
}

func (e *ScriptElement) Src(s string) *ScriptElement {
	e.attributes["src"] = s

	return e
}

func (e *ScriptElement) Nomodule(b bool) *ScriptElement {
	e.attributes["nomodule"] = b

	return e
}

func (e *ScriptElement) Async(b bool) *ScriptElement {
	e.attributes["async"] = b

	return e
}

func (e *ScriptElement) Defer(b bool) *ScriptElement {
	e.attributes["defer"] = b

	return e
}

func (e *ScriptElement) Blocking(a ScriptBlocking) *ScriptElement {
	e.attributes["blocking"] = a

	return e
}

func (e *ScriptElement) Crossorigin(a ScriptCrossorigin) *ScriptElement {
	e.attributes["crossorigin"] = a

	return e
}

func (e *ScriptElement) Referrerpolicy(s string) *ScriptElement {
	e.attributes["referrerpolicy"] = s

	return e
}

func (e *ScriptElement) Integrity(s string) *ScriptElement {
	e.attributes["integrity"] = s

	return e
}

func (e *ScriptElement) Fetchpriority(a ScriptFetchpriority) *ScriptElement {
	e.attributes["fetchpriority"] = a

	return e
}

func (e *ScriptElement) AriaUnsafe(name string, s string) *ScriptElement {
	tag := strings.ToLower("aria-" + name)

	e.attributes[tag] = s

	return e
}

func (e *ScriptElement) Aria(name string, s string) *ScriptElement {
	return e.AriaUnsafe(name, html.EscapeString(s))
}

func (e *ScriptElement) Autocapitalize(a ScriptAutocapitalize) *ScriptElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *ScriptElement) Autocorrect(a ScriptAutocorrect) *ScriptElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *ScriptElement) Autofocus(b bool) *ScriptElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *ScriptElement) Class(s ...string) *ScriptElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *ScriptElement) Contenteditable(a ScriptContenteditable) *ScriptElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *ScriptElement) DataUnsafe(name string, s string) *ScriptElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *ScriptElement) Data(name string, s string) *ScriptElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *ScriptElement) Dir(a ScriptDir) *ScriptElement {
	e.attributes["dir"] = a

	return e
}

func (e *ScriptElement) Draggable(a ScriptDraggable) *ScriptElement {
	e.attributes["draggable"] = a

	return e
}

func (e *ScriptElement) Enterkeyhint(a ScriptEnterkeyhint) *ScriptElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *ScriptElement) Hidden(a ScriptHidden) *ScriptElement {
	e.attributes["hidden"] = a

	return e
}

func (e *ScriptElement) Id(s string) *ScriptElement {
	e.attributes["id"] = s

	return e
}

func (e *ScriptElement) Inert(b bool) *ScriptElement {
	e.attributes["inert"] = b

	return e
}

func (e *ScriptElement) Inputmode(a ScriptInputmode) *ScriptElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *ScriptElement) Itemid(s string) *ScriptElement {
	e.attributes["itemid"] = s

	return e
}

func (e *ScriptElement) Itemprop(s ...string) *ScriptElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *ScriptElement) Itemref(s ...string) *ScriptElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *ScriptElement) Itemscope(b bool) *ScriptElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *ScriptElement) Itemtype(s ...string) *ScriptElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *ScriptElement) Lang(s string) *ScriptElement {
	e.attributes["lang"] = s

	return e
}

func (e *ScriptElement) Nonce(s string) *ScriptElement {
	e.attributes["nonce"] = s

	return e
}

func (e *ScriptElement) Popover(s string) *ScriptElement {
	e.attributes["popover"] = s

	return e
}

func (e *ScriptElement) Role(s string) *ScriptElement {
	e.attributes["role"] = s

	return e
}

func (e *ScriptElement) Slot(s string) *ScriptElement {
	e.attributes["slot"] = s

	return e
}

func (e *ScriptElement) Spellcheck(a ScriptSpellcheck) *ScriptElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *ScriptElement) Style(s string) *ScriptElement {
	e.attributes["style"] = s

	return e
}

func (e *ScriptElement) Tabindex(i int) *ScriptElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *ScriptElement) Title(s string) *ScriptElement {
	e.attributes["title"] = s

	return e
}

func (e *ScriptElement) Translate(a ScriptTranslate) *ScriptElement {
	e.attributes["translate"] = a

	return e
}

func (e *ScriptElement) Writingsuggestions(a ScriptWritingsuggestions) *ScriptElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *ScriptElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	var sb strings.Builder
	sb.WriteString("<script")

	for key, v := range e.attributes {
		sb.WriteByte(' ')
		sb.WriteString(key)

		strVal := fmt.Sprintf("%v", v)
		if strVal != "" {
			sb.WriteByte('=')
			sb.WriteByte('"')
			sb.WriteString(strVal)
			sb.WriteByte('"')
		}
	}

	sb.WriteByte('>')
	for _, child := range e.children {
		if err := child.Render(&sb); err != nil {
			return err
		}
	}

	sb.WriteString("</script>")

	_, err := io.WriteString(w, sb.String())
	return err
}
