// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"strings"

	"github.com/derekmwright/htemel"
	"golang.org/x/net/html"
)

type ScriptElement struct {
	attributes scriptAttrs
	children   []htemel.Node
	skipRender bool
	indent     int
}

// Script creates a tag <script> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The script element allows authors to include dynamic script, instructions to the user agent, and data blocks in their documents. The element does not represent content for the user.
func Script(children ...htemel.Node) *ScriptElement {
	node := &ScriptElement{
		children: children, attributes: make(scriptAttrs),
	}

	return node
}

func ScriptIf(condition bool, children ...htemel.Node) *ScriptElement {
	if condition {
		return Script(children...)
	}

	return &ScriptElement{
		skipRender: true,
	}
}

func ScriptTernary(condition bool, true htemel.Node, false htemel.Node) *ScriptElement {
	if condition {
		return Script(true)
	}

	return Script(false)
}

type ScriptBlockingEnum string

const (
	ScriptBlockingEnumRender ScriptBlockingEnum = "render"
)

type ScriptCrossoriginEnum string

const (
	ScriptCrossoriginEnumAnonymous      ScriptCrossoriginEnum = "anonymous"
	ScriptCrossoriginEnumUseCredentials ScriptCrossoriginEnum = "use-credentials"
	ScriptCrossoriginEnumEmpty          ScriptCrossoriginEnum = ""
)

type ScriptFetchpriorityEnum string

const (
	ScriptFetchpriorityEnumAuto ScriptFetchpriorityEnum = "auto"
	ScriptFetchpriorityEnumHigh ScriptFetchpriorityEnum = "high"
	ScriptFetchpriorityEnumLow  ScriptFetchpriorityEnum = "low"
)

type ScriptAutocapitalizeEnum string

const (
	ScriptAutocapitalizeEnumOn         ScriptAutocapitalizeEnum = "on"
	ScriptAutocapitalizeEnumSentences  ScriptAutocapitalizeEnum = "sentences"
	ScriptAutocapitalizeEnumWords      ScriptAutocapitalizeEnum = "words"
	ScriptAutocapitalizeEnumCharacters ScriptAutocapitalizeEnum = "characters"
	ScriptAutocapitalizeEnumNone       ScriptAutocapitalizeEnum = "none"
	ScriptAutocapitalizeEnumOff        ScriptAutocapitalizeEnum = "off"
)

type ScriptAutocorrectEnum string

const (
	ScriptAutocorrectEnumOff   ScriptAutocorrectEnum = "off"
	ScriptAutocorrectEnumOn    ScriptAutocorrectEnum = "on"
	ScriptAutocorrectEnumEmpty ScriptAutocorrectEnum = ""
)

type ScriptContenteditableEnum string

const (
	ScriptContenteditableEnumFalse         ScriptContenteditableEnum = "false"
	ScriptContenteditableEnumPlaintextOnly ScriptContenteditableEnum = "plaintext-only"
	ScriptContenteditableEnumTrue          ScriptContenteditableEnum = "true"
	ScriptContenteditableEnumEmpty         ScriptContenteditableEnum = ""
)

type ScriptDirEnum string

const (
	ScriptDirEnumAuto ScriptDirEnum = "auto"
	ScriptDirEnumLtr  ScriptDirEnum = "ltr"
	ScriptDirEnumRtl  ScriptDirEnum = "rtl"
)

type ScriptDraggableEnum string

const (
	ScriptDraggableEnumFalse ScriptDraggableEnum = "false"
	ScriptDraggableEnumTrue  ScriptDraggableEnum = "true"
)

type ScriptEnterkeyhintEnum string

const (
	ScriptEnterkeyhintEnumDone     ScriptEnterkeyhintEnum = "done"
	ScriptEnterkeyhintEnumEnter    ScriptEnterkeyhintEnum = "enter"
	ScriptEnterkeyhintEnumGo       ScriptEnterkeyhintEnum = "go"
	ScriptEnterkeyhintEnumNext     ScriptEnterkeyhintEnum = "next"
	ScriptEnterkeyhintEnumPrevious ScriptEnterkeyhintEnum = "previous"
	ScriptEnterkeyhintEnumSearch   ScriptEnterkeyhintEnum = "search"
	ScriptEnterkeyhintEnumSend     ScriptEnterkeyhintEnum = "send"
)

type ScriptHiddenEnum string

const (
	ScriptHiddenEnumHidden     ScriptHiddenEnum = "hidden"
	ScriptHiddenEnumUntilFound ScriptHiddenEnum = "until-found"
	ScriptHiddenEnumEmpty      ScriptHiddenEnum = ""
)

type ScriptInputmodeEnum string

const (
	ScriptInputmodeEnumUrl     ScriptInputmodeEnum = "url"
	ScriptInputmodeEnumDecimal ScriptInputmodeEnum = "decimal"
	ScriptInputmodeEnumEmail   ScriptInputmodeEnum = "email"
	ScriptInputmodeEnumNone    ScriptInputmodeEnum = "none"
	ScriptInputmodeEnumNumeric ScriptInputmodeEnum = "numeric"
	ScriptInputmodeEnumSearch  ScriptInputmodeEnum = "search"
	ScriptInputmodeEnumTel     ScriptInputmodeEnum = "tel"
	ScriptInputmodeEnumText    ScriptInputmodeEnum = "text"
)

type ScriptSpellcheckEnum string

const (
	ScriptSpellcheckEnumFalse ScriptSpellcheckEnum = "false"
	ScriptSpellcheckEnumTrue  ScriptSpellcheckEnum = "true"
	ScriptSpellcheckEnumEmpty ScriptSpellcheckEnum = ""
)

type ScriptTranslateEnum string

const (
	ScriptTranslateEnumYes   ScriptTranslateEnum = "yes"
	ScriptTranslateEnumNo    ScriptTranslateEnum = "no"
	ScriptTranslateEnumEmpty ScriptTranslateEnum = ""
)

type ScriptWritingsuggestionsEnum string

const (
	ScriptWritingsuggestionsEnumFalse ScriptWritingsuggestionsEnum = "false"
	ScriptWritingsuggestionsEnumTrue  ScriptWritingsuggestionsEnum = "true"
	ScriptWritingsuggestionsEnumEmpty ScriptWritingsuggestionsEnum = ""
)

type scriptAttrs map[string]any

func (e *ScriptElement) Type(s string) *ScriptElement {
	e.attributes["type"] = s

	return e
}

func (e *ScriptElement) Src(s string) *ScriptElement {
	e.attributes["src"] = s

	return e
}

func (e *ScriptElement) Nomodule(b bool) *ScriptElement {
	e.attributes["nomodule"] = b

	return e
}

func (e *ScriptElement) Async(b bool) *ScriptElement {
	e.attributes["async"] = b

	return e
}

func (e *ScriptElement) Defer(b bool) *ScriptElement {
	e.attributes["defer"] = b

	return e
}

func (e *ScriptElement) Blocking(a ScriptBlockingEnum) *ScriptElement {
	e.attributes["blocking"] = a

	return e
}

func (e *ScriptElement) Crossorigin(a ScriptCrossoriginEnum) *ScriptElement {
	e.attributes["crossorigin"] = a

	return e
}

func (e *ScriptElement) Referrerpolicy(s string) *ScriptElement {
	e.attributes["referrerpolicy"] = s

	return e
}

func (e *ScriptElement) Integrity(s string) *ScriptElement {
	e.attributes["integrity"] = s

	return e
}

func (e *ScriptElement) Fetchpriority(a ScriptFetchpriorityEnum) *ScriptElement {
	e.attributes["fetchpriority"] = a

	return e
}

func (e *ScriptElement) Autocapitalize(a ScriptAutocapitalizeEnum) *ScriptElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *ScriptElement) Autocorrect(a ScriptAutocorrectEnum) *ScriptElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *ScriptElement) Autofocus(b bool) *ScriptElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *ScriptElement) Class(s ...string) *ScriptElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *ScriptElement) Contenteditable(a ScriptContenteditableEnum) *ScriptElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *ScriptElement) DataUnsafe(name string, s string) *ScriptElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *ScriptElement) Data(name string, s string) *ScriptElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *ScriptElement) Dir(a ScriptDirEnum) *ScriptElement {
	e.attributes["dir"] = a

	return e
}

func (e *ScriptElement) Draggable(a ScriptDraggableEnum) *ScriptElement {
	e.attributes["draggable"] = a

	return e
}

func (e *ScriptElement) Enterkeyhint(a ScriptEnterkeyhintEnum) *ScriptElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *ScriptElement) Hidden(a ScriptHiddenEnum) *ScriptElement {
	e.attributes["hidden"] = a

	return e
}

func (e *ScriptElement) Id(s string) *ScriptElement {
	e.attributes["id"] = s

	return e
}

func (e *ScriptElement) Inert(b bool) *ScriptElement {
	e.attributes["inert"] = b

	return e
}

func (e *ScriptElement) Inputmode(a ScriptInputmodeEnum) *ScriptElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *ScriptElement) Itemid(s string) *ScriptElement {
	e.attributes["itemid"] = s

	return e
}

func (e *ScriptElement) Itemprop(s ...string) *ScriptElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *ScriptElement) Itemref(s ...string) *ScriptElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *ScriptElement) Itemscope(b bool) *ScriptElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *ScriptElement) Itemtype(s ...string) *ScriptElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *ScriptElement) Lang(s string) *ScriptElement {
	e.attributes["lang"] = s

	return e
}

func (e *ScriptElement) Nonce(s string) *ScriptElement {
	e.attributes["nonce"] = s

	return e
}

func (e *ScriptElement) Popover(s string) *ScriptElement {
	e.attributes["popover"] = s

	return e
}

func (e *ScriptElement) Slot(s string) *ScriptElement {
	e.attributes["slot"] = s

	return e
}

func (e *ScriptElement) Spellcheck(a ScriptSpellcheckEnum) *ScriptElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *ScriptElement) Style(s string) *ScriptElement {
	e.attributes["style"] = s

	return e
}

func (e *ScriptElement) Tabindex(i int) *ScriptElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *ScriptElement) Title(s string) *ScriptElement {
	e.attributes["title"] = s

	return e
}

func (e *ScriptElement) Translate(a ScriptTranslateEnum) *ScriptElement {
	e.attributes["translate"] = a

	return e
}

func (e *ScriptElement) Writingsuggestions(a ScriptWritingsuggestionsEnum) *ScriptElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *ScriptElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<script")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key))

		// Enum types support empty attributes and can be omitted.
		if fmt.Sprintf("%s", v) == "" {
			w.Write([]byte(" "))
			continue
		}

		w.Write([]byte("="))

		w.Write([]byte("\"" + fmt.Sprintf("%v", v) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}
	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</script>")); err != nil {
		return err
	}

	return nil
}
