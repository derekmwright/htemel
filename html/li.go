// Code generated by htemel. DO NOT EDIT.
package html

import (
  "fmt"
  "github.com/derekmwright/htemel"
  "golang.org/x/net/html"
  "io"
  "strings"
)

type LiElement struct {
	attributes liAttrs
	children []htemel.Node
	skipRender bool
}

// Li creates a tag <li> instance and returns it for further modification.
// Any children passed will be nested within the tag.
//
// Spec Description: The li element represents a list item. If its parent element is an ol, ul, or menu element, then the element is an item of the parent element's list, as defined for those elements. Otherwise, the list item has no defined list-related relationship to any other li element.
func Li(children ...htemel.Node) *LiElement {
	node := &LiElement{
		children: children,
		attributes: make(liAttrs),
	}

	return node
}

func LiIf(condition bool, children ...htemel.Node) *LiElement {
	if condition {
		return Li(children...)
	}

	return &LiElement{
		skipRender: true,
	}
}

type LiAutocapitalizeAttrEnum string

const (
	LiAutocapitalizeAttrEnumCharacters LiAutocapitalizeAttrEnum = "characters"
	LiAutocapitalizeAttrEnumNone LiAutocapitalizeAttrEnum = "none"
	LiAutocapitalizeAttrEnumOff LiAutocapitalizeAttrEnum = "off"
	LiAutocapitalizeAttrEnumOn LiAutocapitalizeAttrEnum = "on"
	LiAutocapitalizeAttrEnumSentences LiAutocapitalizeAttrEnum = "sentences"
	LiAutocapitalizeAttrEnumWords LiAutocapitalizeAttrEnum = "words"
)

type LiAutocorrectAttrEnum string

const (
	LiAutocorrectAttrEnumOff LiAutocorrectAttrEnum = "off"
	LiAutocorrectAttrEnumOn LiAutocorrectAttrEnum = "on"
)

type LiContenteditableAttrEnum string

const (
	LiContenteditableAttrEnumPlaintextOnly LiContenteditableAttrEnum = "plaintext-only"
	LiContenteditableAttrEnumTrue LiContenteditableAttrEnum = "true"
	LiContenteditableAttrEnumFalse LiContenteditableAttrEnum = "false"
)

type liAttrs map[string]any

func (e *LiElement) Autocapitalize(a LiAutocapitalizeAttrEnum) *LiElement {
	e.attributes["autocapitalize"] = a
	
	return e
}

func (e *LiElement) Autocorrect(a LiAutocorrectAttrEnum) *LiElement {
	e.attributes["autocorrect"] = a
	
	return e
}

func (e *LiElement) Class(s ...string) *LiElement {
	e.attributes["class"] = strings.Join(s, " ")
	
	return e
}

func (e *LiElement) Contenteditable(a LiContenteditableAttrEnum) *LiElement {
	e.attributes["contenteditable"] = a
	
	return e
}

func (e *LiElement) Id(s string) *LiElement {
	e.attributes["id"] = s
	
	return e
}

func (e *LiElement) Slot(s string) *LiElement {
	e.attributes["slot"] = s
	
	return e
}

func (e *LiElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<li")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		w.Write([]byte(" " + key + "="))
		w.Write([]byte("\"" + html.EscapeString(fmt.Sprintf("%v", v)) + "\""))
		if i < c {
			w.Write([]byte(" "))
		}
		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}

	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</li>")); err != nil {
		return err
	}

	return nil
}
