// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"slices"
	"strings"

	"github.com/go-htemel/htemel"
	"golang.org/x/net/html"
)

type LiElement struct {
	attributes liAttrs
	children   []htemel.Node
	skipRender bool
}

// Li creates a tag <li> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The li element represents a list item. If its parent element is an ol, ul, or menu element, then the element is an item of the parent element's list, as defined for those elements. Otherwise, the list item has no defined list-related relationship to any other li element.
func Li(children ...htemel.Node) *LiElement {
	node := &LiElement{
		children:   children,
		attributes: make(liAttrs),
	}

	return node
}

func LiIf(condition bool, children ...htemel.Node) *LiElement {
	if condition {
		return Li(children...)
	}

	return &LiElement{
		children:   children,
		attributes: make(liAttrs),
		skipRender: true,
	}
}

func LiTernary(condition bool, true htemel.Node, false htemel.Node) *LiElement {
	if condition {
		return Li(true)
	}
	return Li(false)
}

// Children appends children to this element.
func (e *LiElement) Children(children ...htemel.Node) *LiElement {
	e.children = append(e.children, children...)
	return e
}

// With allows passing a function to modify the element via a closure.
func (e *LiElement) With(fn func(*LiElement)) *LiElement {
	fn(e)
	return e
}

// Text adds a text node to the element.
func (e *LiElement) Text(text string) *LiElement {
	return e.Children(htemel.Text(text))
}

// Textf adds a text node to the element with the given format string and arguments.
func (e *LiElement) Textf(format string, args ...any) *LiElement {
	return e.Children(htemel.Text(fmt.Sprintf(format, args...)))
}

// If conditionally adds a child node to the element if the condition is true, otherwise it is a no-op.
func (e *LiElement) If(cond bool, child htemel.Node) *LiElement {
	if cond {
		return e.Children(child)
	}
	return e
}

func (e *LiElement) IfElse(cond bool, then, els htemel.Node) *LiElement {
	if cond {
		e.Children(then)
	} else {
		e.Children(els)
	}
	return e
}

// IfThen conditionally calls the given function with the element if the condition is true, otherwise it is a no-op.
func (e *LiElement) IfThen(cond bool, fn func(*LiElement)) *LiElement {
	if cond {
		fn(e)
	}
	return e
}

// AddClass appends a class to the element.
func (e *LiElement) AddClass(classes ...string) *LiElement {
	current := e.attributes["class"].(string)
	all := append(strings.Fields(current), classes...)
	e.attributes["class"] = strings.Join(all, " ")
	return e
}

// ToggleClass toggles a class on or off.
func (e *LiElement) ToggleClass(class string, enable bool) *LiElement {
	classes := strings.Fields(e.attributes["class"].(string))
	idx := slices.Index(classes, class)
	if enable && idx == -1 {
		classes = append(classes, class)
	} else if !enable && idx >= 0 {
		classes = slices.Delete(classes, idx, idx+1)
	}
	e.attributes["class"] = strings.Join(classes, " ")
	return e
}

type LiAutocapitalize string

const (
	LiAutocapitalizeWords      LiAutocapitalize = "words"
	LiAutocapitalizeCharacters LiAutocapitalize = "characters"
	LiAutocapitalizeNone       LiAutocapitalize = "none"
	LiAutocapitalizeOff        LiAutocapitalize = "off"
	LiAutocapitalizeOn         LiAutocapitalize = "on"
	LiAutocapitalizeSentences  LiAutocapitalize = "sentences"
)

type LiAutocorrect string

const (
	LiAutocorrectOff   LiAutocorrect = "off"
	LiAutocorrectOn    LiAutocorrect = "on"
	LiAutocorrectEmpty LiAutocorrect = ""
)

type LiContenteditable string

const (
	LiContenteditableFalse         LiContenteditable = "false"
	LiContenteditablePlaintextOnly LiContenteditable = "plaintext-only"
	LiContenteditableTrue          LiContenteditable = "true"
	LiContenteditableEmpty         LiContenteditable = ""
)

type LiDir string

const (
	LiDirAuto LiDir = "auto"
	LiDirLtr  LiDir = "ltr"
	LiDirRtl  LiDir = "rtl"
)

type LiDraggable string

const (
	LiDraggableFalse LiDraggable = "false"
	LiDraggableTrue  LiDraggable = "true"
)

type LiEnterkeyhint string

const (
	LiEnterkeyhintPrevious LiEnterkeyhint = "previous"
	LiEnterkeyhintSearch   LiEnterkeyhint = "search"
	LiEnterkeyhintSend     LiEnterkeyhint = "send"
	LiEnterkeyhintDone     LiEnterkeyhint = "done"
	LiEnterkeyhintEnter    LiEnterkeyhint = "enter"
	LiEnterkeyhintGo       LiEnterkeyhint = "go"
	LiEnterkeyhintNext     LiEnterkeyhint = "next"
)

type LiHidden string

const (
	LiHiddenHidden     LiHidden = "hidden"
	LiHiddenUntilFound LiHidden = "until-found"
	LiHiddenEmpty      LiHidden = ""
)

type LiInputmode string

const (
	LiInputmodeNumeric LiInputmode = "numeric"
	LiInputmodeSearch  LiInputmode = "search"
	LiInputmodeTel     LiInputmode = "tel"
	LiInputmodeText    LiInputmode = "text"
	LiInputmodeUrl     LiInputmode = "url"
	LiInputmodeDecimal LiInputmode = "decimal"
	LiInputmodeEmail   LiInputmode = "email"
	LiInputmodeNone    LiInputmode = "none"
)

type LiSpellcheck string

const (
	LiSpellcheckFalse LiSpellcheck = "false"
	LiSpellcheckTrue  LiSpellcheck = "true"
	LiSpellcheckEmpty LiSpellcheck = ""
)

type LiTranslate string

const (
	LiTranslateNo    LiTranslate = "no"
	LiTranslateYes   LiTranslate = "yes"
	LiTranslateEmpty LiTranslate = ""
)

type LiWritingsuggestions string

const (
	LiWritingsuggestionsFalse LiWritingsuggestions = "false"
	LiWritingsuggestionsTrue  LiWritingsuggestions = "true"
	LiWritingsuggestionsEmpty LiWritingsuggestions = ""
)

type liAttrs map[string]any

func (e *LiElement) Value(i int) *LiElement {
	e.attributes["value"] = i

	return e
}

func (e *LiElement) AriaUnsafe(name string, s string) *LiElement {
	tag := strings.ToLower("aria-" + name)

	e.attributes[tag] = s

	return e
}

func (e *LiElement) Aria(name string, s string) *LiElement {
	return e.AriaUnsafe(name, html.EscapeString(s))
}

func (e *LiElement) Autocapitalize(a LiAutocapitalize) *LiElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *LiElement) Autocorrect(a LiAutocorrect) *LiElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *LiElement) Autofocus(b bool) *LiElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *LiElement) Class(s ...string) *LiElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *LiElement) Contenteditable(a LiContenteditable) *LiElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *LiElement) DataUnsafe(name string, s string) *LiElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *LiElement) Data(name string, s string) *LiElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *LiElement) Dir(a LiDir) *LiElement {
	e.attributes["dir"] = a

	return e
}

func (e *LiElement) Draggable(a LiDraggable) *LiElement {
	e.attributes["draggable"] = a

	return e
}

func (e *LiElement) Enterkeyhint(a LiEnterkeyhint) *LiElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *LiElement) Hidden(a LiHidden) *LiElement {
	e.attributes["hidden"] = a

	return e
}

func (e *LiElement) Id(s string) *LiElement {
	e.attributes["id"] = s

	return e
}

func (e *LiElement) Inert(b bool) *LiElement {
	e.attributes["inert"] = b

	return e
}

func (e *LiElement) Inputmode(a LiInputmode) *LiElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *LiElement) Itemid(s string) *LiElement {
	e.attributes["itemid"] = s

	return e
}

func (e *LiElement) Itemprop(s ...string) *LiElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *LiElement) Itemref(s ...string) *LiElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *LiElement) Itemscope(b bool) *LiElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *LiElement) Itemtype(s ...string) *LiElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *LiElement) Lang(s string) *LiElement {
	e.attributes["lang"] = s

	return e
}

func (e *LiElement) Nonce(s string) *LiElement {
	e.attributes["nonce"] = s

	return e
}

func (e *LiElement) Popover(s string) *LiElement {
	e.attributes["popover"] = s

	return e
}

func (e *LiElement) Role(s string) *LiElement {
	e.attributes["role"] = s

	return e
}

func (e *LiElement) Slot(s string) *LiElement {
	e.attributes["slot"] = s

	return e
}

func (e *LiElement) Spellcheck(a LiSpellcheck) *LiElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *LiElement) Style(s string) *LiElement {
	e.attributes["style"] = s

	return e
}

func (e *LiElement) Tabindex(i int) *LiElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *LiElement) Title(s string) *LiElement {
	e.attributes["title"] = s

	return e
}

func (e *LiElement) Translate(a LiTranslate) *LiElement {
	e.attributes["translate"] = a

	return e
}

func (e *LiElement) Writingsuggestions(a LiWritingsuggestions) *LiElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *LiElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	var sb strings.Builder
	sb.WriteString("<li")

	for key, v := range e.attributes {
		sb.WriteByte(' ')
		sb.WriteString(key)

		strVal := fmt.Sprintf("%v", v)
		if strVal != "" {
			sb.WriteByte('=')
			sb.WriteByte('"')
			sb.WriteString(strVal)
			sb.WriteByte('"')
		}
	}

	sb.WriteByte('>')
	for _, child := range e.children {
		if err := child.Render(&sb); err != nil {
			return err
		}
	}

	sb.WriteString("</li>")

	_, err := io.WriteString(w, sb.String())
	return err
}
