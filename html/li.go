// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"strings"

	"github.com/derekmwright/htemel"
	"golang.org/x/net/html"
)

type LiElement struct {
	attributes liAttrs
	children   []htemel.Node
	skipRender bool
	indent     int
}

// Li creates a tag <li> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The li element represents a list item. If its parent element is an ol, ul, or menu element, then the element is an item of the parent element's list, as defined for those elements. Otherwise, the list item has no defined list-related relationship to any other li element.
func Li(children ...htemel.Node) *LiElement {
	node := &LiElement{
		children: children, attributes: make(liAttrs),
	}

	return node
}

func LiIf(condition bool, children ...htemel.Node) *LiElement {
	if condition {
		return Li(children...)
	}

	return &LiElement{
		skipRender: true,
	}
}

func LiTernary(condition bool, true htemel.Node, false htemel.Node) *LiElement {
	if condition {
		return Li(true)
	}

	return Li(false)
}

type LiAutocapitalizeEnum string

const (
	LiAutocapitalizeEnumCharacters LiAutocapitalizeEnum = "characters"
	LiAutocapitalizeEnumNone       LiAutocapitalizeEnum = "none"
	LiAutocapitalizeEnumOff        LiAutocapitalizeEnum = "off"
	LiAutocapitalizeEnumOn         LiAutocapitalizeEnum = "on"
	LiAutocapitalizeEnumSentences  LiAutocapitalizeEnum = "sentences"
	LiAutocapitalizeEnumWords      LiAutocapitalizeEnum = "words"
)

type LiAutocorrectEnum string

const (
	LiAutocorrectEnumOff   LiAutocorrectEnum = "off"
	LiAutocorrectEnumOn    LiAutocorrectEnum = "on"
	LiAutocorrectEnumEmpty LiAutocorrectEnum = ""
)

type LiContenteditableEnum string

const (
	LiContenteditableEnumFalse         LiContenteditableEnum = "false"
	LiContenteditableEnumPlaintextOnly LiContenteditableEnum = "plaintext-only"
	LiContenteditableEnumTrue          LiContenteditableEnum = "true"
	LiContenteditableEnumEmpty         LiContenteditableEnum = ""
)

type LiDirEnum string

const (
	LiDirEnumAuto LiDirEnum = "auto"
	LiDirEnumLtr  LiDirEnum = "ltr"
	LiDirEnumRtl  LiDirEnum = "rtl"
)

type LiDraggableEnum string

const (
	LiDraggableEnumFalse LiDraggableEnum = "false"
	LiDraggableEnumTrue  LiDraggableEnum = "true"
)

type LiEnterkeyhintEnum string

const (
	LiEnterkeyhintEnumEnter    LiEnterkeyhintEnum = "enter"
	LiEnterkeyhintEnumGo       LiEnterkeyhintEnum = "go"
	LiEnterkeyhintEnumNext     LiEnterkeyhintEnum = "next"
	LiEnterkeyhintEnumPrevious LiEnterkeyhintEnum = "previous"
	LiEnterkeyhintEnumSearch   LiEnterkeyhintEnum = "search"
	LiEnterkeyhintEnumSend     LiEnterkeyhintEnum = "send"
	LiEnterkeyhintEnumDone     LiEnterkeyhintEnum = "done"
)

type LiHiddenEnum string

const (
	LiHiddenEnumHidden     LiHiddenEnum = "hidden"
	LiHiddenEnumUntilFound LiHiddenEnum = "until-found"
	LiHiddenEnumEmpty      LiHiddenEnum = ""
)

type LiInputmodeEnum string

const (
	LiInputmodeEnumNone    LiInputmodeEnum = "none"
	LiInputmodeEnumNumeric LiInputmodeEnum = "numeric"
	LiInputmodeEnumSearch  LiInputmodeEnum = "search"
	LiInputmodeEnumTel     LiInputmodeEnum = "tel"
	LiInputmodeEnumText    LiInputmodeEnum = "text"
	LiInputmodeEnumUrl     LiInputmodeEnum = "url"
	LiInputmodeEnumDecimal LiInputmodeEnum = "decimal"
	LiInputmodeEnumEmail   LiInputmodeEnum = "email"
)

type LiSpellcheckEnum string

const (
	LiSpellcheckEnumFalse LiSpellcheckEnum = "false"
	LiSpellcheckEnumTrue  LiSpellcheckEnum = "true"
	LiSpellcheckEnumEmpty LiSpellcheckEnum = ""
)

type LiTranslateEnum string

const (
	LiTranslateEnumNo    LiTranslateEnum = "no"
	LiTranslateEnumYes   LiTranslateEnum = "yes"
	LiTranslateEnumEmpty LiTranslateEnum = ""
)

type LiWritingsuggestionsEnum string

const (
	LiWritingsuggestionsEnumFalse LiWritingsuggestionsEnum = "false"
	LiWritingsuggestionsEnumTrue  LiWritingsuggestionsEnum = "true"
	LiWritingsuggestionsEnumEmpty LiWritingsuggestionsEnum = ""
)

type liAttrs map[string]any

func (e *LiElement) Value(i int) *LiElement {
	e.attributes["value"] = i

	return e
}

func (e *LiElement) Autocapitalize(a LiAutocapitalizeEnum) *LiElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *LiElement) Autocorrect(a LiAutocorrectEnum) *LiElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *LiElement) Autofocus(b bool) *LiElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *LiElement) Class(s ...string) *LiElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *LiElement) Contenteditable(a LiContenteditableEnum) *LiElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *LiElement) DataUnsafe(name string, s string) *LiElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *LiElement) Data(name string, s string) *LiElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *LiElement) Dir(a LiDirEnum) *LiElement {
	e.attributes["dir"] = a

	return e
}

func (e *LiElement) Draggable(a LiDraggableEnum) *LiElement {
	e.attributes["draggable"] = a

	return e
}

func (e *LiElement) Enterkeyhint(a LiEnterkeyhintEnum) *LiElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *LiElement) Hidden(a LiHiddenEnum) *LiElement {
	e.attributes["hidden"] = a

	return e
}

func (e *LiElement) Id(s string) *LiElement {
	e.attributes["id"] = s

	return e
}

func (e *LiElement) Inert(b bool) *LiElement {
	e.attributes["inert"] = b

	return e
}

func (e *LiElement) Inputmode(a LiInputmodeEnum) *LiElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *LiElement) Itemid(s string) *LiElement {
	e.attributes["itemid"] = s

	return e
}

func (e *LiElement) Itemprop(s ...string) *LiElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *LiElement) Itemref(s ...string) *LiElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *LiElement) Itemscope(b bool) *LiElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *LiElement) Itemtype(s ...string) *LiElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *LiElement) Lang(s string) *LiElement {
	e.attributes["lang"] = s

	return e
}

func (e *LiElement) Nonce(s string) *LiElement {
	e.attributes["nonce"] = s

	return e
}

func (e *LiElement) Popover(s string) *LiElement {
	e.attributes["popover"] = s

	return e
}

func (e *LiElement) Slot(s string) *LiElement {
	e.attributes["slot"] = s

	return e
}

func (e *LiElement) Spellcheck(a LiSpellcheckEnum) *LiElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *LiElement) Style(s string) *LiElement {
	e.attributes["style"] = s

	return e
}

func (e *LiElement) Tabindex(i int) *LiElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *LiElement) Title(s string) *LiElement {
	e.attributes["title"] = s

	return e
}

func (e *LiElement) Translate(a LiTranslateEnum) *LiElement {
	e.attributes["translate"] = a

	return e
}

func (e *LiElement) Writingsuggestions(a LiWritingsuggestionsEnum) *LiElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *LiElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<li")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key))

		// Enum types support empty attributes and can be omitted.
		if fmt.Sprintf("%s", v) == "" {
			w.Write([]byte(" "))
			continue
		}

		w.Write([]byte("="))

		w.Write([]byte("\"" + fmt.Sprintf("%v", v) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}
	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</li>")); err != nil {
		return err
	}

	return nil
}
