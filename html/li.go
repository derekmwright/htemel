// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"strings"

	"github.com/derekmwright/htemel"
	"golang.org/x/net/html"
)

type LiElement struct {
	attributes liAttrs
	children   []htemel.Node
	skipRender bool
}

// Li creates a tag <li> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The li element represents a list item. If its parent element is an ol, ul, or menu element, then the element is an item of the parent element's list, as defined for those elements. Otherwise, the list item has no defined list-related relationship to any other li element.
func Li(children ...htemel.Node) *LiElement {
	node := &LiElement{
		children:   children,
		attributes: make(liAttrs),
	}

	return node
}

func LiIf(condition bool, children ...htemel.Node) *LiElement {
	if condition {
		return Li(children...)
	}

	return &LiElement{
		children:   children,
		attributes: make(liAttrs),
		skipRender: true,
	}
}

func LiTernary(condition bool, true htemel.Node, false htemel.Node) *LiElement {
	if condition {
		return Li(true)
	}

	return Li(false)
}

type LiAutocapitalize string

const (
	LiAutocapitalizeSentences  LiAutocapitalize = "sentences"
	LiAutocapitalizeWords      LiAutocapitalize = "words"
	LiAutocapitalizeCharacters LiAutocapitalize = "characters"
	LiAutocapitalizeNone       LiAutocapitalize = "none"
	LiAutocapitalizeOff        LiAutocapitalize = "off"
	LiAutocapitalizeOn         LiAutocapitalize = "on"
)

type LiAutocorrect string

const (
	LiAutocorrectOff   LiAutocorrect = "off"
	LiAutocorrectOn    LiAutocorrect = "on"
	LiAutocorrectEmpty LiAutocorrect = ""
)

type LiContenteditable string

const (
	LiContenteditableFalse         LiContenteditable = "false"
	LiContenteditablePlaintextOnly LiContenteditable = "plaintext-only"
	LiContenteditableTrue          LiContenteditable = "true"
	LiContenteditableEmpty         LiContenteditable = ""
)

type LiDir string

const (
	LiDirAuto LiDir = "auto"
	LiDirLtr  LiDir = "ltr"
	LiDirRtl  LiDir = "rtl"
)

type LiDraggable string

const (
	LiDraggableFalse LiDraggable = "false"
	LiDraggableTrue  LiDraggable = "true"
)

type LiEnterkeyhint string

const (
	LiEnterkeyhintGo       LiEnterkeyhint = "go"
	LiEnterkeyhintNext     LiEnterkeyhint = "next"
	LiEnterkeyhintPrevious LiEnterkeyhint = "previous"
	LiEnterkeyhintSearch   LiEnterkeyhint = "search"
	LiEnterkeyhintSend     LiEnterkeyhint = "send"
	LiEnterkeyhintDone     LiEnterkeyhint = "done"
	LiEnterkeyhintEnter    LiEnterkeyhint = "enter"
)

type LiHidden string

const (
	LiHiddenHidden     LiHidden = "hidden"
	LiHiddenUntilFound LiHidden = "until-found"
	LiHiddenEmpty      LiHidden = ""
)

type LiInputmode string

const (
	LiInputmodeNumeric LiInputmode = "numeric"
	LiInputmodeSearch  LiInputmode = "search"
	LiInputmodeTel     LiInputmode = "tel"
	LiInputmodeText    LiInputmode = "text"
	LiInputmodeUrl     LiInputmode = "url"
	LiInputmodeDecimal LiInputmode = "decimal"
	LiInputmodeEmail   LiInputmode = "email"
	LiInputmodeNone    LiInputmode = "none"
)

type LiSpellcheck string

const (
	LiSpellcheckFalse LiSpellcheck = "false"
	LiSpellcheckTrue  LiSpellcheck = "true"
	LiSpellcheckEmpty LiSpellcheck = ""
)

type LiTranslate string

const (
	LiTranslateNo    LiTranslate = "no"
	LiTranslateYes   LiTranslate = "yes"
	LiTranslateEmpty LiTranslate = ""
)

type LiWritingsuggestions string

const (
	LiWritingsuggestionsTrue  LiWritingsuggestions = "true"
	LiWritingsuggestionsFalse LiWritingsuggestions = "false"
	LiWritingsuggestionsEmpty LiWritingsuggestions = ""
)

type liAttrs map[string]any

func (e *LiElement) Value(i int) *LiElement {
	e.attributes["value"] = i

	return e
}

func (e *LiElement) AriaUnsafe(name string, s string) *LiElement {
	tag := strings.ToLower("aria-" + name)

	e.attributes[tag] = s

	return e
}

func (e *LiElement) Aria(name string, s string) *LiElement {
	return e.AriaUnsafe(name, html.EscapeString(s))
}

func (e *LiElement) Autocapitalize(a LiAutocapitalize) *LiElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *LiElement) Autocorrect(a LiAutocorrect) *LiElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *LiElement) Autofocus(b bool) *LiElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *LiElement) Class(s ...string) *LiElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *LiElement) Contenteditable(a LiContenteditable) *LiElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *LiElement) DataUnsafe(name string, s string) *LiElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *LiElement) Data(name string, s string) *LiElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *LiElement) Dir(a LiDir) *LiElement {
	e.attributes["dir"] = a

	return e
}

func (e *LiElement) Draggable(a LiDraggable) *LiElement {
	e.attributes["draggable"] = a

	return e
}

func (e *LiElement) Enterkeyhint(a LiEnterkeyhint) *LiElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *LiElement) Hidden(a LiHidden) *LiElement {
	e.attributes["hidden"] = a

	return e
}

func (e *LiElement) Id(s string) *LiElement {
	e.attributes["id"] = s

	return e
}

func (e *LiElement) Inert(b bool) *LiElement {
	e.attributes["inert"] = b

	return e
}

func (e *LiElement) Inputmode(a LiInputmode) *LiElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *LiElement) Itemid(s string) *LiElement {
	e.attributes["itemid"] = s

	return e
}

func (e *LiElement) Itemprop(s ...string) *LiElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *LiElement) Itemref(s ...string) *LiElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *LiElement) Itemscope(b bool) *LiElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *LiElement) Itemtype(s ...string) *LiElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *LiElement) Lang(s string) *LiElement {
	e.attributes["lang"] = s

	return e
}

func (e *LiElement) Nonce(s string) *LiElement {
	e.attributes["nonce"] = s

	return e
}

func (e *LiElement) Popover(s string) *LiElement {
	e.attributes["popover"] = s

	return e
}

func (e *LiElement) Role(s string) *LiElement {
	e.attributes["role"] = s

	return e
}

func (e *LiElement) Slot(s string) *LiElement {
	e.attributes["slot"] = s

	return e
}

func (e *LiElement) Spellcheck(a LiSpellcheck) *LiElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *LiElement) Style(s string) *LiElement {
	e.attributes["style"] = s

	return e
}

func (e *LiElement) Tabindex(i int) *LiElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *LiElement) Title(s string) *LiElement {
	e.attributes["title"] = s

	return e
}

func (e *LiElement) Translate(a LiTranslate) *LiElement {
	e.attributes["translate"] = a

	return e
}

func (e *LiElement) Writingsuggestions(a LiWritingsuggestions) *LiElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *LiElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<li")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key))

		// Enum types support empty attributes and can be omitted.
		if fmt.Sprintf("%s", v) == "" {
			w.Write([]byte(" "))
			continue
		}

		w.Write([]byte("="))

		w.Write([]byte("\"" + fmt.Sprintf("%v", v) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}
	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</li>")); err != nil {
		return err
	}

	return nil
}
