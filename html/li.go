// Code generated by htemel. DO NOT EDIT.
package html

import (
  "fmt"
  "github.com/derekmwright/htemel"
  "golang.org/x/net/html"
  "io"
  "strings"
)

type LiElement struct {
	attributes liAttrs
	children []htemel.Node
	skipRender bool
}

// Li creates a tag <li> instance and returns it for further modification.
// Any children passed will be nested within the tag.
//
// Spec Description: The li element represents a list item. If its parent element is an ol, ul, or menu element, then the element is an item of the parent element's list, as defined for those elements. Otherwise, the list item has no defined list-related relationship to any other li element.
func Li(children ...htemel.Node) *LiElement {
	node := &LiElement{
		children: children,
		attributes: make(liAttrs),
	}

	return node
}

func LiIf(condition bool, children ...htemel.Node) *LiElement {
	if condition {
		return Li(children...)
	}

	return &LiElement{
		skipRender: true,
	}
}

type LiAutocapitalizeEnum string

const (
	LiAutocapitalizeEnumOff LiAutocapitalizeEnum = "off"
	LiAutocapitalizeEnumOn LiAutocapitalizeEnum = "on"
	LiAutocapitalizeEnumSentences LiAutocapitalizeEnum = "sentences"
	LiAutocapitalizeEnumWords LiAutocapitalizeEnum = "words"
	LiAutocapitalizeEnumCharacters LiAutocapitalizeEnum = "characters"
	LiAutocapitalizeEnumNone LiAutocapitalizeEnum = "none"
)

type LiAutocorrectEnum string

const (
	LiAutocorrectEnumOff LiAutocorrectEnum = "off"
	LiAutocorrectEnumOn LiAutocorrectEnum = "on"
)

type LiContenteditableEnum string

const (
	LiContenteditableEnumFalse LiContenteditableEnum = "false"
	LiContenteditableEnumPlaintextOnly LiContenteditableEnum = "plaintext-only"
	LiContenteditableEnumTrue LiContenteditableEnum = "true"
)

type LiDirEnum string

const (
	LiDirEnumAuto LiDirEnum = "auto"
	LiDirEnumLtr LiDirEnum = "ltr"
	LiDirEnumRtl LiDirEnum = "rtl"
)

type LiDraggableEnum string

const (
	LiDraggableEnumFalse LiDraggableEnum = "false"
	LiDraggableEnumTrue LiDraggableEnum = "true"
)

type LiEnterkeyhintEnum string

const (
	LiEnterkeyhintEnumNext LiEnterkeyhintEnum = "next"
	LiEnterkeyhintEnumPrevious LiEnterkeyhintEnum = "previous"
	LiEnterkeyhintEnumSearch LiEnterkeyhintEnum = "search"
	LiEnterkeyhintEnumSend LiEnterkeyhintEnum = "send"
	LiEnterkeyhintEnumDone LiEnterkeyhintEnum = "done"
	LiEnterkeyhintEnumEnter LiEnterkeyhintEnum = "enter"
	LiEnterkeyhintEnumGo LiEnterkeyhintEnum = "go"
)

type LiHiddenEnum string

const (
	LiHiddenEnumHidden LiHiddenEnum = "hidden"
	LiHiddenEnumUntilFound LiHiddenEnum = "until-found"
)

type liAttrs map[string]any

func (e *LiElement) Autocapitalize(a LiAutocapitalizeEnum) *LiElement {
	e.attributes["autocapitalize"] = a
	
	return e
}

func (e *LiElement) Autocorrect(a LiAutocorrectEnum) *LiElement {
	e.attributes["autocorrect"] = a
	
	return e
}

func (e *LiElement) Autofocus(b bool) *LiElement {
	e.attributes["autofocus"] = b
	
	return e
}

func (e *LiElement) Class(s ...string) *LiElement {
	e.attributes["class"] = strings.Join(s, " ")
	
	return e
}

func (e *LiElement) Contenteditable(a LiContenteditableEnum) *LiElement {
	e.attributes["contenteditable"] = a
	
	return e
}

func (e *LiElement) Dir(a LiDirEnum) *LiElement {
	e.attributes["dir"] = a
	
	return e
}

func (e *LiElement) Draggable(a LiDraggableEnum) *LiElement {
	e.attributes["draggable"] = a
	
	return e
}

func (e *LiElement) Enterkeyhint(a LiEnterkeyhintEnum) *LiElement {
	e.attributes["enterkeyhint"] = a
	
	return e
}

func (e *LiElement) Hidden(a LiHiddenEnum) *LiElement {
	e.attributes["hidden"] = a
	
	return e
}

func (e *LiElement) Id(s string) *LiElement {
	e.attributes["id"] = s
	
	return e
}

func (e *LiElement) Slot(s string) *LiElement {
	e.attributes["slot"] = s
	
	return e
}

func (e *LiElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<li")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key + "="))
		w.Write([]byte("\"" + html.EscapeString(fmt.Sprintf("%v", v)) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}

	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</li>")); err != nil {
		return err
	}

	return nil
}
