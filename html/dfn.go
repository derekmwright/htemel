// Code generated by htemel. DO NOT EDIT.
package html

import (
  "fmt"
  "github.com/derekmwright/htemel"
  "golang.org/x/net/html"
  "io"
  "strings"
)

type DfnElement struct {
	attributes dfnAttrs
	children []htemel.Node
	skipRender bool
}

// Dfn creates a tag <dfn> instance and returns it for further modification.
// Any children passed will be nested within the tag.
//
// Spec Description: The dfn element represents the defining instance of a term. The paragraph, description list group, or section that is the nearest ancestor of the dfn element must also contain the definition(s) for the term given by the dfn element.
func Dfn(children ...htemel.Node) *DfnElement {
	node := &DfnElement{
		children: children,
		attributes: make(dfnAttrs),
	}

	return node
}

func DfnIf(condition bool, children ...htemel.Node) *DfnElement {
	if condition {
		return Dfn(children...)
	}

	return &DfnElement{
		skipRender: true,
	}
}

type DfnAutocapitalizeEnum string

const (
	DfnAutocapitalizeEnumNone DfnAutocapitalizeEnum = "none"
	DfnAutocapitalizeEnumOff DfnAutocapitalizeEnum = "off"
	DfnAutocapitalizeEnumOn DfnAutocapitalizeEnum = "on"
	DfnAutocapitalizeEnumSentences DfnAutocapitalizeEnum = "sentences"
	DfnAutocapitalizeEnumWords DfnAutocapitalizeEnum = "words"
	DfnAutocapitalizeEnumCharacters DfnAutocapitalizeEnum = "characters"
)

type DfnAutocorrectEnum string

const (
	DfnAutocorrectEnumOff DfnAutocorrectEnum = "off"
	DfnAutocorrectEnumOn DfnAutocorrectEnum = "on"
)

type DfnContenteditableEnum string

const (
	DfnContenteditableEnumFalse DfnContenteditableEnum = "false"
	DfnContenteditableEnumPlaintextOnly DfnContenteditableEnum = "plaintext-only"
	DfnContenteditableEnumTrue DfnContenteditableEnum = "true"
)

type DfnDirEnum string

const (
	DfnDirEnumAuto DfnDirEnum = "auto"
	DfnDirEnumLtr DfnDirEnum = "ltr"
	DfnDirEnumRtl DfnDirEnum = "rtl"
)

type DfnDraggableEnum string

const (
	DfnDraggableEnumFalse DfnDraggableEnum = "false"
	DfnDraggableEnumTrue DfnDraggableEnum = "true"
)

type DfnEnterkeyhintEnum string

const (
	DfnEnterkeyhintEnumPrevious DfnEnterkeyhintEnum = "previous"
	DfnEnterkeyhintEnumSearch DfnEnterkeyhintEnum = "search"
	DfnEnterkeyhintEnumSend DfnEnterkeyhintEnum = "send"
	DfnEnterkeyhintEnumDone DfnEnterkeyhintEnum = "done"
	DfnEnterkeyhintEnumEnter DfnEnterkeyhintEnum = "enter"
	DfnEnterkeyhintEnumGo DfnEnterkeyhintEnum = "go"
	DfnEnterkeyhintEnumNext DfnEnterkeyhintEnum = "next"
)

type DfnHiddenEnum string

const (
	DfnHiddenEnumHidden DfnHiddenEnum = "hidden"
	DfnHiddenEnumUntilFound DfnHiddenEnum = "until-found"
)

type dfnAttrs map[string]any

func (e *DfnElement) Autocapitalize(a DfnAutocapitalizeEnum) *DfnElement {
	e.attributes["autocapitalize"] = a
	
	return e
}

func (e *DfnElement) Autocorrect(a DfnAutocorrectEnum) *DfnElement {
	e.attributes["autocorrect"] = a
	
	return e
}

func (e *DfnElement) Autofocus(b bool) *DfnElement {
	e.attributes["autofocus"] = b
	
	return e
}

func (e *DfnElement) Class(s ...string) *DfnElement {
	e.attributes["class"] = strings.Join(s, " ")
	
	return e
}

func (e *DfnElement) Contenteditable(a DfnContenteditableEnum) *DfnElement {
	e.attributes["contenteditable"] = a
	
	return e
}

func (e *DfnElement) Dir(a DfnDirEnum) *DfnElement {
	e.attributes["dir"] = a
	
	return e
}

func (e *DfnElement) Draggable(a DfnDraggableEnum) *DfnElement {
	e.attributes["draggable"] = a
	
	return e
}

func (e *DfnElement) Enterkeyhint(a DfnEnterkeyhintEnum) *DfnElement {
	e.attributes["enterkeyhint"] = a
	
	return e
}

func (e *DfnElement) Hidden(a DfnHiddenEnum) *DfnElement {
	e.attributes["hidden"] = a
	
	return e
}

func (e *DfnElement) Id(s string) *DfnElement {
	e.attributes["id"] = s
	
	return e
}

func (e *DfnElement) Slot(s string) *DfnElement {
	e.attributes["slot"] = s
	
	return e
}

func (e *DfnElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<dfn")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key + "="))
		w.Write([]byte("\"" + html.EscapeString(fmt.Sprintf("%v", v)) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}

	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</dfn>")); err != nil {
		return err
	}

	return nil
}
