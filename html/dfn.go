// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"slices"
	"strings"

	"github.com/derekmwright/htemel"
	"golang.org/x/net/html"
)

type DfnElement struct {
	attributes dfnAttrs
	children   []htemel.Node
	skipRender bool
}

// Dfn creates a tag <dfn> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The dfn element represents the defining instance of a term. The paragraph, description list group, or section that is the nearest ancestor of the dfn element must also contain the definition(s) for the term given by the dfn element.
func Dfn(children ...htemel.Node) *DfnElement {
	node := &DfnElement{
		children:   children,
		attributes: make(dfnAttrs),
	}

	return node
}

func DfnIf(condition bool, children ...htemel.Node) *DfnElement {
	if condition {
		return Dfn(children...)
	}

	return &DfnElement{
		children:   children,
		attributes: make(dfnAttrs),
		skipRender: true,
	}
}

func DfnTernary(condition bool, true htemel.Node, false htemel.Node) *DfnElement {
	if condition {
		return Dfn(true)
	}
	return Dfn(false)
}

// Children appends children to this element.
func (e *DfnElement) Children(children ...htemel.Node) *DfnElement {
	e.children = append(e.children, children...)
	return e
}

// With allows passing a function to modify the element via a closure.
func (e *DfnElement) With(fn func(*DfnElement)) *DfnElement {
	fn(e)
	return e
}

// Text adds a text node to the element.
func (e *DfnElement) Text(text string) *DfnElement {
	return e.Children(htemel.Text(text))
}

// Textf adds a text node to the element with the given format string and arguments.
func (e *DfnElement) Textf(format string, args ...any) *DfnElement {
	return e.Children(htemel.Text(fmt.Sprintf(format, args...)))
}

// If conditionally adds a child node to the element if the condition is true, otherwise it is a no-op.
func (e *DfnElement) If(cond bool, child htemel.Node) *DfnElement {
	if cond {
		return e.Children(child)
	}
	return e
}

func (e *DfnElement) IfElse(cond bool, then, els htemel.Node) *DfnElement {
	if cond {
		e.Children(then)
	} else {
		e.Children(els)
	}
	return e
}

// IfThen conditionally calls the given function with the element if the condition is true, otherwise it is a no-op.
func (e *DfnElement) IfThen(cond bool, fn func(*DfnElement)) *DfnElement {
	if cond {
		fn(e)
	}
	return e
}

// AddClass appends a class to the element.
func (e *DfnElement) AddClass(classes ...string) *DfnElement {
	current := e.attributes["class"].(string)
	all := append(strings.Fields(current), classes...)
	e.attributes["class"] = strings.Join(all, " ")
	return e
}

// ToggleClass toggles a class on or off.
func (e *DfnElement) ToggleClass(class string, enable bool) *DfnElement {
	classes := strings.Fields(e.attributes["class"].(string))
	idx := slices.Index(classes, class)
	if enable && idx == -1 {
		classes = append(classes, class)
	} else if !enable && idx >= 0 {
		classes = slices.Delete(classes, idx, idx+1)
	}
	e.attributes["class"] = strings.Join(classes, " ")
	return e
}

type DfnAutocapitalize string

const (
	DfnAutocapitalizeSentences  DfnAutocapitalize = "sentences"
	DfnAutocapitalizeWords      DfnAutocapitalize = "words"
	DfnAutocapitalizeCharacters DfnAutocapitalize = "characters"
	DfnAutocapitalizeNone       DfnAutocapitalize = "none"
	DfnAutocapitalizeOff        DfnAutocapitalize = "off"
	DfnAutocapitalizeOn         DfnAutocapitalize = "on"
)

type DfnAutocorrect string

const (
	DfnAutocorrectOff   DfnAutocorrect = "off"
	DfnAutocorrectOn    DfnAutocorrect = "on"
	DfnAutocorrectEmpty DfnAutocorrect = ""
)

type DfnContenteditable string

const (
	DfnContenteditableFalse         DfnContenteditable = "false"
	DfnContenteditablePlaintextOnly DfnContenteditable = "plaintext-only"
	DfnContenteditableTrue          DfnContenteditable = "true"
	DfnContenteditableEmpty         DfnContenteditable = ""
)

type DfnDir string

const (
	DfnDirAuto DfnDir = "auto"
	DfnDirLtr  DfnDir = "ltr"
	DfnDirRtl  DfnDir = "rtl"
)

type DfnDraggable string

const (
	DfnDraggableFalse DfnDraggable = "false"
	DfnDraggableTrue  DfnDraggable = "true"
)

type DfnEnterkeyhint string

const (
	DfnEnterkeyhintSearch   DfnEnterkeyhint = "search"
	DfnEnterkeyhintSend     DfnEnterkeyhint = "send"
	DfnEnterkeyhintDone     DfnEnterkeyhint = "done"
	DfnEnterkeyhintEnter    DfnEnterkeyhint = "enter"
	DfnEnterkeyhintGo       DfnEnterkeyhint = "go"
	DfnEnterkeyhintNext     DfnEnterkeyhint = "next"
	DfnEnterkeyhintPrevious DfnEnterkeyhint = "previous"
)

type DfnHidden string

const (
	DfnHiddenHidden     DfnHidden = "hidden"
	DfnHiddenUntilFound DfnHidden = "until-found"
	DfnHiddenEmpty      DfnHidden = ""
)

type DfnInputmode string

const (
	DfnInputmodeDecimal DfnInputmode = "decimal"
	DfnInputmodeEmail   DfnInputmode = "email"
	DfnInputmodeNone    DfnInputmode = "none"
	DfnInputmodeNumeric DfnInputmode = "numeric"
	DfnInputmodeSearch  DfnInputmode = "search"
	DfnInputmodeTel     DfnInputmode = "tel"
	DfnInputmodeText    DfnInputmode = "text"
	DfnInputmodeUrl     DfnInputmode = "url"
)

type DfnSpellcheck string

const (
	DfnSpellcheckFalse DfnSpellcheck = "false"
	DfnSpellcheckTrue  DfnSpellcheck = "true"
	DfnSpellcheckEmpty DfnSpellcheck = ""
)

type DfnTranslate string

const (
	DfnTranslateYes   DfnTranslate = "yes"
	DfnTranslateNo    DfnTranslate = "no"
	DfnTranslateEmpty DfnTranslate = ""
)

type DfnWritingsuggestions string

const (
	DfnWritingsuggestionsFalse DfnWritingsuggestions = "false"
	DfnWritingsuggestionsTrue  DfnWritingsuggestions = "true"
	DfnWritingsuggestionsEmpty DfnWritingsuggestions = ""
)

type dfnAttrs map[string]any

func (e *DfnElement) AriaUnsafe(name string, s string) *DfnElement {
	tag := strings.ToLower("aria-" + name)

	e.attributes[tag] = s

	return e
}

func (e *DfnElement) Aria(name string, s string) *DfnElement {
	return e.AriaUnsafe(name, html.EscapeString(s))
}

func (e *DfnElement) Autocapitalize(a DfnAutocapitalize) *DfnElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *DfnElement) Autocorrect(a DfnAutocorrect) *DfnElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *DfnElement) Autofocus(b bool) *DfnElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *DfnElement) Class(s ...string) *DfnElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *DfnElement) Contenteditable(a DfnContenteditable) *DfnElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *DfnElement) DataUnsafe(name string, s string) *DfnElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *DfnElement) Data(name string, s string) *DfnElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *DfnElement) Dir(a DfnDir) *DfnElement {
	e.attributes["dir"] = a

	return e
}

func (e *DfnElement) Draggable(a DfnDraggable) *DfnElement {
	e.attributes["draggable"] = a

	return e
}

func (e *DfnElement) Enterkeyhint(a DfnEnterkeyhint) *DfnElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *DfnElement) Hidden(a DfnHidden) *DfnElement {
	e.attributes["hidden"] = a

	return e
}

func (e *DfnElement) Id(s string) *DfnElement {
	e.attributes["id"] = s

	return e
}

func (e *DfnElement) Inert(b bool) *DfnElement {
	e.attributes["inert"] = b

	return e
}

func (e *DfnElement) Inputmode(a DfnInputmode) *DfnElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *DfnElement) Itemid(s string) *DfnElement {
	e.attributes["itemid"] = s

	return e
}

func (e *DfnElement) Itemprop(s ...string) *DfnElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *DfnElement) Itemref(s ...string) *DfnElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *DfnElement) Itemscope(b bool) *DfnElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *DfnElement) Itemtype(s ...string) *DfnElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *DfnElement) Lang(s string) *DfnElement {
	e.attributes["lang"] = s

	return e
}

func (e *DfnElement) Nonce(s string) *DfnElement {
	e.attributes["nonce"] = s

	return e
}

func (e *DfnElement) Popover(s string) *DfnElement {
	e.attributes["popover"] = s

	return e
}

func (e *DfnElement) Role(s string) *DfnElement {
	e.attributes["role"] = s

	return e
}

func (e *DfnElement) Slot(s string) *DfnElement {
	e.attributes["slot"] = s

	return e
}

func (e *DfnElement) Spellcheck(a DfnSpellcheck) *DfnElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *DfnElement) Style(s string) *DfnElement {
	e.attributes["style"] = s

	return e
}

func (e *DfnElement) Tabindex(i int) *DfnElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *DfnElement) Title(s string) *DfnElement {
	e.attributes["title"] = s

	return e
}

func (e *DfnElement) Translate(a DfnTranslate) *DfnElement {
	e.attributes["translate"] = a

	return e
}

func (e *DfnElement) Writingsuggestions(a DfnWritingsuggestions) *DfnElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *DfnElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	var sb strings.Builder
	sb.WriteString("<dfn")

	for key, v := range e.attributes {
		sb.WriteByte(' ')
		sb.WriteString(key)

		strVal := fmt.Sprintf("%v", v)
		if strVal != "" {
			sb.WriteByte('=')
			sb.WriteByte('"')
			sb.WriteString(strVal)
			sb.WriteByte('"')
		}
	}

	sb.WriteByte('>')
	for _, child := range e.children {
		if err := child.Render(&sb); err != nil {
			return err
		}
	}

	sb.WriteString("</dfn>")

	_, err := io.WriteString(w, sb.String())
	return err
}
