// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"strings"

	"github.com/derekmwright/htemel"
	"golang.org/x/net/html"
)

type DfnElement struct {
	attributes dfnAttrs
	children   []htemel.Node
	skipRender bool
}

// Dfn creates a tag <dfn> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The dfn element represents the defining instance of a term. The paragraph, description list group, or section that is the nearest ancestor of the dfn element must also contain the definition(s) for the term given by the dfn element.
func Dfn(children ...htemel.Node) *DfnElement {
	node := &DfnElement{
		children:   children,
		attributes: make(dfnAttrs),
	}

	return node
}

func DfnIf(condition bool, children ...htemel.Node) *DfnElement {
	if condition {
		return Dfn(children...)
	}

	return &DfnElement{
		children:   children,
		attributes: make(dfnAttrs),
		skipRender: true,
	}
}

func DfnTernary(condition bool, true htemel.Node, false htemel.Node) *DfnElement {
	if condition {
		return Dfn(true)
	}

	return Dfn(false)
}

// Children appends children to this element.
func (e *DfnElement) Children(children ...htemel.Node) *DfnElement {
	e.children = append(e.children, children...)

	return e
}

type DfnAutocapitalize string

const (
	DfnAutocapitalizeNone       DfnAutocapitalize = "none"
	DfnAutocapitalizeOff        DfnAutocapitalize = "off"
	DfnAutocapitalizeOn         DfnAutocapitalize = "on"
	DfnAutocapitalizeSentences  DfnAutocapitalize = "sentences"
	DfnAutocapitalizeWords      DfnAutocapitalize = "words"
	DfnAutocapitalizeCharacters DfnAutocapitalize = "characters"
)

type DfnAutocorrect string

const (
	DfnAutocorrectOff   DfnAutocorrect = "off"
	DfnAutocorrectOn    DfnAutocorrect = "on"
	DfnAutocorrectEmpty DfnAutocorrect = ""
)

type DfnContenteditable string

const (
	DfnContenteditableTrue          DfnContenteditable = "true"
	DfnContenteditableFalse         DfnContenteditable = "false"
	DfnContenteditablePlaintextOnly DfnContenteditable = "plaintext-only"
	DfnContenteditableEmpty         DfnContenteditable = ""
)

type DfnDir string

const (
	DfnDirLtr  DfnDir = "ltr"
	DfnDirRtl  DfnDir = "rtl"
	DfnDirAuto DfnDir = "auto"
)

type DfnDraggable string

const (
	DfnDraggableFalse DfnDraggable = "false"
	DfnDraggableTrue  DfnDraggable = "true"
)

type DfnEnterkeyhint string

const (
	DfnEnterkeyhintNext     DfnEnterkeyhint = "next"
	DfnEnterkeyhintPrevious DfnEnterkeyhint = "previous"
	DfnEnterkeyhintSearch   DfnEnterkeyhint = "search"
	DfnEnterkeyhintSend     DfnEnterkeyhint = "send"
	DfnEnterkeyhintDone     DfnEnterkeyhint = "done"
	DfnEnterkeyhintEnter    DfnEnterkeyhint = "enter"
	DfnEnterkeyhintGo       DfnEnterkeyhint = "go"
)

type DfnHidden string

const (
	DfnHiddenHidden     DfnHidden = "hidden"
	DfnHiddenUntilFound DfnHidden = "until-found"
	DfnHiddenEmpty      DfnHidden = ""
)

type DfnInputmode string

const (
	DfnInputmodeNumeric DfnInputmode = "numeric"
	DfnInputmodeSearch  DfnInputmode = "search"
	DfnInputmodeTel     DfnInputmode = "tel"
	DfnInputmodeText    DfnInputmode = "text"
	DfnInputmodeUrl     DfnInputmode = "url"
	DfnInputmodeDecimal DfnInputmode = "decimal"
	DfnInputmodeEmail   DfnInputmode = "email"
	DfnInputmodeNone    DfnInputmode = "none"
)

type DfnSpellcheck string

const (
	DfnSpellcheckFalse DfnSpellcheck = "false"
	DfnSpellcheckTrue  DfnSpellcheck = "true"
	DfnSpellcheckEmpty DfnSpellcheck = ""
)

type DfnTranslate string

const (
	DfnTranslateNo    DfnTranslate = "no"
	DfnTranslateYes   DfnTranslate = "yes"
	DfnTranslateEmpty DfnTranslate = ""
)

type DfnWritingsuggestions string

const (
	DfnWritingsuggestionsFalse DfnWritingsuggestions = "false"
	DfnWritingsuggestionsTrue  DfnWritingsuggestions = "true"
	DfnWritingsuggestionsEmpty DfnWritingsuggestions = ""
)

type dfnAttrs map[string]any

func (e *DfnElement) AriaUnsafe(name string, s string) *DfnElement {
	tag := strings.ToLower("aria-" + name)

	e.attributes[tag] = s

	return e
}

func (e *DfnElement) Aria(name string, s string) *DfnElement {
	return e.AriaUnsafe(name, html.EscapeString(s))
}

func (e *DfnElement) Autocapitalize(a DfnAutocapitalize) *DfnElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *DfnElement) Autocorrect(a DfnAutocorrect) *DfnElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *DfnElement) Autofocus(b bool) *DfnElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *DfnElement) Class(s ...string) *DfnElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *DfnElement) Contenteditable(a DfnContenteditable) *DfnElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *DfnElement) DataUnsafe(name string, s string) *DfnElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *DfnElement) Data(name string, s string) *DfnElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *DfnElement) Dir(a DfnDir) *DfnElement {
	e.attributes["dir"] = a

	return e
}

func (e *DfnElement) Draggable(a DfnDraggable) *DfnElement {
	e.attributes["draggable"] = a

	return e
}

func (e *DfnElement) Enterkeyhint(a DfnEnterkeyhint) *DfnElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *DfnElement) Hidden(a DfnHidden) *DfnElement {
	e.attributes["hidden"] = a

	return e
}

func (e *DfnElement) Id(s string) *DfnElement {
	e.attributes["id"] = s

	return e
}

func (e *DfnElement) Inert(b bool) *DfnElement {
	e.attributes["inert"] = b

	return e
}

func (e *DfnElement) Inputmode(a DfnInputmode) *DfnElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *DfnElement) Itemid(s string) *DfnElement {
	e.attributes["itemid"] = s

	return e
}

func (e *DfnElement) Itemprop(s ...string) *DfnElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *DfnElement) Itemref(s ...string) *DfnElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *DfnElement) Itemscope(b bool) *DfnElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *DfnElement) Itemtype(s ...string) *DfnElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *DfnElement) Lang(s string) *DfnElement {
	e.attributes["lang"] = s

	return e
}

func (e *DfnElement) Nonce(s string) *DfnElement {
	e.attributes["nonce"] = s

	return e
}

func (e *DfnElement) Popover(s string) *DfnElement {
	e.attributes["popover"] = s

	return e
}

func (e *DfnElement) Role(s string) *DfnElement {
	e.attributes["role"] = s

	return e
}

func (e *DfnElement) Slot(s string) *DfnElement {
	e.attributes["slot"] = s

	return e
}

func (e *DfnElement) Spellcheck(a DfnSpellcheck) *DfnElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *DfnElement) Style(s string) *DfnElement {
	e.attributes["style"] = s

	return e
}

func (e *DfnElement) Tabindex(i int) *DfnElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *DfnElement) Title(s string) *DfnElement {
	e.attributes["title"] = s

	return e
}

func (e *DfnElement) Translate(a DfnTranslate) *DfnElement {
	e.attributes["translate"] = a

	return e
}

func (e *DfnElement) Writingsuggestions(a DfnWritingsuggestions) *DfnElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *DfnElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<dfn")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key))

		// Enum types support empty attributes and can be omitted.
		if fmt.Sprintf("%s", v) == "" {
			w.Write([]byte(" "))
			continue
		}

		w.Write([]byte("="))

		w.Write([]byte("\"" + fmt.Sprintf("%v", v) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}
	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</dfn>")); err != nil {
		return err
	}

	return nil
}
