// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"strings"

	"github.com/derekmwright/htemel"
	"golang.org/x/net/html"
)

type BElement struct {
	attributes bAttrs
	children   []htemel.Node
	skipRender bool
}

// B creates a tag <b> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The b element represents a span of text to which attention is being drawn for utilitarian purposes without conveying any extra importance and with no implication of an alternate voice or mood, such as key words in a document abstract, product names in a review, actionable words in interactive text-driven software, or an article lede.
func B(children ...htemel.Node) *BElement {
	node := &BElement{
		children:   children,
		attributes: make(bAttrs),
	}

	return node
}

func BIf(condition bool, children ...htemel.Node) *BElement {
	if condition {
		return B(children...)
	}

	return &BElement{
		children:   children,
		attributes: make(bAttrs),
		skipRender: true,
	}
}

func BTernary(condition bool, true htemel.Node, false htemel.Node) *BElement {
	if condition {
		return B(true)
	}

	return B(false)
}

type BAutocapitalize string

const (
	BAutocapitalizeCharacters BAutocapitalize = "characters"
	BAutocapitalizeNone       BAutocapitalize = "none"
	BAutocapitalizeOff        BAutocapitalize = "off"
	BAutocapitalizeOn         BAutocapitalize = "on"
	BAutocapitalizeSentences  BAutocapitalize = "sentences"
	BAutocapitalizeWords      BAutocapitalize = "words"
)

type BAutocorrect string

const (
	BAutocorrectOff   BAutocorrect = "off"
	BAutocorrectOn    BAutocorrect = "on"
	BAutocorrectEmpty BAutocorrect = ""
)

type BContenteditable string

const (
	BContenteditablePlaintextOnly BContenteditable = "plaintext-only"
	BContenteditableTrue          BContenteditable = "true"
	BContenteditableFalse         BContenteditable = "false"
	BContenteditableEmpty         BContenteditable = ""
)

type BDir string

const (
	BDirAuto BDir = "auto"
	BDirLtr  BDir = "ltr"
	BDirRtl  BDir = "rtl"
)

type BDraggable string

const (
	BDraggableFalse BDraggable = "false"
	BDraggableTrue  BDraggable = "true"
)

type BEnterkeyhint string

const (
	BEnterkeyhintSearch   BEnterkeyhint = "search"
	BEnterkeyhintSend     BEnterkeyhint = "send"
	BEnterkeyhintDone     BEnterkeyhint = "done"
	BEnterkeyhintEnter    BEnterkeyhint = "enter"
	BEnterkeyhintGo       BEnterkeyhint = "go"
	BEnterkeyhintNext     BEnterkeyhint = "next"
	BEnterkeyhintPrevious BEnterkeyhint = "previous"
)

type BHidden string

const (
	BHiddenHidden     BHidden = "hidden"
	BHiddenUntilFound BHidden = "until-found"
	BHiddenEmpty      BHidden = ""
)

type BInputmode string

const (
	BInputmodeEmail   BInputmode = "email"
	BInputmodeNone    BInputmode = "none"
	BInputmodeNumeric BInputmode = "numeric"
	BInputmodeSearch  BInputmode = "search"
	BInputmodeTel     BInputmode = "tel"
	BInputmodeText    BInputmode = "text"
	BInputmodeUrl     BInputmode = "url"
	BInputmodeDecimal BInputmode = "decimal"
)

type BSpellcheck string

const (
	BSpellcheckFalse BSpellcheck = "false"
	BSpellcheckTrue  BSpellcheck = "true"
	BSpellcheckEmpty BSpellcheck = ""
)

type BTranslate string

const (
	BTranslateYes   BTranslate = "yes"
	BTranslateNo    BTranslate = "no"
	BTranslateEmpty BTranslate = ""
)

type BWritingsuggestions string

const (
	BWritingsuggestionsFalse BWritingsuggestions = "false"
	BWritingsuggestionsTrue  BWritingsuggestions = "true"
	BWritingsuggestionsEmpty BWritingsuggestions = ""
)

type bAttrs map[string]any

func (e *BElement) AriaUnsafe(name string, s string) *BElement {
	tag := strings.ToLower("aria-" + name)

	e.attributes[tag] = s

	return e
}

func (e *BElement) Aria(name string, s string) *BElement {
	return e.AriaUnsafe(name, html.EscapeString(s))
}

func (e *BElement) Autocapitalize(a BAutocapitalize) *BElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *BElement) Autocorrect(a BAutocorrect) *BElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *BElement) Autofocus(b bool) *BElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *BElement) Class(s ...string) *BElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *BElement) Contenteditable(a BContenteditable) *BElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *BElement) DataUnsafe(name string, s string) *BElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *BElement) Data(name string, s string) *BElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *BElement) Dir(a BDir) *BElement {
	e.attributes["dir"] = a

	return e
}

func (e *BElement) Draggable(a BDraggable) *BElement {
	e.attributes["draggable"] = a

	return e
}

func (e *BElement) Enterkeyhint(a BEnterkeyhint) *BElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *BElement) Hidden(a BHidden) *BElement {
	e.attributes["hidden"] = a

	return e
}

func (e *BElement) Id(s string) *BElement {
	e.attributes["id"] = s

	return e
}

func (e *BElement) Inert(b bool) *BElement {
	e.attributes["inert"] = b

	return e
}

func (e *BElement) Inputmode(a BInputmode) *BElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *BElement) Itemid(s string) *BElement {
	e.attributes["itemid"] = s

	return e
}

func (e *BElement) Itemprop(s ...string) *BElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *BElement) Itemref(s ...string) *BElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *BElement) Itemscope(b bool) *BElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *BElement) Itemtype(s ...string) *BElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *BElement) Lang(s string) *BElement {
	e.attributes["lang"] = s

	return e
}

func (e *BElement) Nonce(s string) *BElement {
	e.attributes["nonce"] = s

	return e
}

func (e *BElement) Popover(s string) *BElement {
	e.attributes["popover"] = s

	return e
}

func (e *BElement) Role(s string) *BElement {
	e.attributes["role"] = s

	return e
}

func (e *BElement) Slot(s string) *BElement {
	e.attributes["slot"] = s

	return e
}

func (e *BElement) Spellcheck(a BSpellcheck) *BElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *BElement) Style(s string) *BElement {
	e.attributes["style"] = s

	return e
}

func (e *BElement) Tabindex(i int) *BElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *BElement) Title(s string) *BElement {
	e.attributes["title"] = s

	return e
}

func (e *BElement) Translate(a BTranslate) *BElement {
	e.attributes["translate"] = a

	return e
}

func (e *BElement) Writingsuggestions(a BWritingsuggestions) *BElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *BElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<b")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key))

		// Enum types support empty attributes and can be omitted.
		if fmt.Sprintf("%s", v) == "" {
			w.Write([]byte(" "))
			continue
		}

		w.Write([]byte("="))

		w.Write([]byte("\"" + fmt.Sprintf("%v", v) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}
	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</b>")); err != nil {
		return err
	}

	return nil
}
