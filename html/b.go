// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"strings"

	"github.com/derekmwright/htemel"
	"golang.org/x/net/html"
)

type BElement struct {
	attributes bAttrs
	children   []htemel.Node
	skipRender bool
	indent     int
}

// B creates a tag <b> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The b element represents a span of text to which attention is being drawn for utilitarian purposes without conveying any extra importance and with no implication of an alternate voice or mood, such as key words in a document abstract, product names in a review, actionable words in interactive text-driven software, or an article lede.
func B(children ...htemel.Node) *BElement {
	node := &BElement{
		children: children, attributes: make(bAttrs),
	}

	return node
}

func BIf(condition bool, children ...htemel.Node) *BElement {
	if condition {
		return B(children...)
	}

	return &BElement{
		skipRender: true,
	}
}

func BTernary(condition bool, true htemel.Node, false htemel.Node) *BElement {
	if condition {
		return B(true)
	}

	return B(false)
}

// AddIndent is called by the Render function on children elements to set their indentation.
func (e *BElement) Indent() int {
	return e.indent
}

// AddIndent is called by the Render function on children elements to set their indentation.
// The parent should pass its own indentation value and this function will increment it for itself.
func (e *BElement) AddIndent(i int) {
	e.indent = i + 1
}

type BAutocapitalizeEnum string

const (
	BAutocapitalizeEnumNone       BAutocapitalizeEnum = "none"
	BAutocapitalizeEnumOff        BAutocapitalizeEnum = "off"
	BAutocapitalizeEnumOn         BAutocapitalizeEnum = "on"
	BAutocapitalizeEnumSentences  BAutocapitalizeEnum = "sentences"
	BAutocapitalizeEnumWords      BAutocapitalizeEnum = "words"
	BAutocapitalizeEnumCharacters BAutocapitalizeEnum = "characters"
)

type BAutocorrectEnum string

const (
	BAutocorrectEnumOff   BAutocorrectEnum = "off"
	BAutocorrectEnumOn    BAutocorrectEnum = "on"
	BAutocorrectEnumEmpty BAutocorrectEnum = ""
)

type BContenteditableEnum string

const (
	BContenteditableEnumFalse         BContenteditableEnum = "false"
	BContenteditableEnumPlaintextOnly BContenteditableEnum = "plaintext-only"
	BContenteditableEnumTrue          BContenteditableEnum = "true"
	BContenteditableEnumEmpty         BContenteditableEnum = ""
)

type BDirEnum string

const (
	BDirEnumAuto BDirEnum = "auto"
	BDirEnumLtr  BDirEnum = "ltr"
	BDirEnumRtl  BDirEnum = "rtl"
)

type BDraggableEnum string

const (
	BDraggableEnumFalse BDraggableEnum = "false"
	BDraggableEnumTrue  BDraggableEnum = "true"
)

type BEnterkeyhintEnum string

const (
	BEnterkeyhintEnumGo       BEnterkeyhintEnum = "go"
	BEnterkeyhintEnumNext     BEnterkeyhintEnum = "next"
	BEnterkeyhintEnumPrevious BEnterkeyhintEnum = "previous"
	BEnterkeyhintEnumSearch   BEnterkeyhintEnum = "search"
	BEnterkeyhintEnumSend     BEnterkeyhintEnum = "send"
	BEnterkeyhintEnumDone     BEnterkeyhintEnum = "done"
	BEnterkeyhintEnumEnter    BEnterkeyhintEnum = "enter"
)

type BHiddenEnum string

const (
	BHiddenEnumHidden     BHiddenEnum = "hidden"
	BHiddenEnumUntilFound BHiddenEnum = "until-found"
	BHiddenEnumEmpty      BHiddenEnum = ""
)

type BInputmodeEnum string

const (
	BInputmodeEnumUrl     BInputmodeEnum = "url"
	BInputmodeEnumDecimal BInputmodeEnum = "decimal"
	BInputmodeEnumEmail   BInputmodeEnum = "email"
	BInputmodeEnumNone    BInputmodeEnum = "none"
	BInputmodeEnumNumeric BInputmodeEnum = "numeric"
	BInputmodeEnumSearch  BInputmodeEnum = "search"
	BInputmodeEnumTel     BInputmodeEnum = "tel"
	BInputmodeEnumText    BInputmodeEnum = "text"
)

type BSpellcheckEnum string

const (
	BSpellcheckEnumFalse BSpellcheckEnum = "false"
	BSpellcheckEnumTrue  BSpellcheckEnum = "true"
	BSpellcheckEnumEmpty BSpellcheckEnum = ""
)

type BTranslateEnum string

const (
	BTranslateEnumNo    BTranslateEnum = "no"
	BTranslateEnumYes   BTranslateEnum = "yes"
	BTranslateEnumEmpty BTranslateEnum = ""
)

type BWritingsuggestionsEnum string

const (
	BWritingsuggestionsEnumFalse BWritingsuggestionsEnum = "false"
	BWritingsuggestionsEnumTrue  BWritingsuggestionsEnum = "true"
	BWritingsuggestionsEnumEmpty BWritingsuggestionsEnum = ""
)

type bAttrs map[string]any

func (e *BElement) Autocapitalize(a BAutocapitalizeEnum) *BElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *BElement) Autocorrect(a BAutocorrectEnum) *BElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *BElement) Autofocus(b bool) *BElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *BElement) Class(s ...string) *BElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *BElement) Contenteditable(a BContenteditableEnum) *BElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *BElement) DataUnsafe(name string, s string) *BElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *BElement) Data(name string, s string) *BElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *BElement) Dir(a BDirEnum) *BElement {
	e.attributes["dir"] = a

	return e
}

func (e *BElement) Draggable(a BDraggableEnum) *BElement {
	e.attributes["draggable"] = a

	return e
}

func (e *BElement) Enterkeyhint(a BEnterkeyhintEnum) *BElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *BElement) Hidden(a BHiddenEnum) *BElement {
	e.attributes["hidden"] = a

	return e
}

func (e *BElement) Id(s string) *BElement {
	e.attributes["id"] = s

	return e
}

func (e *BElement) Inert(b bool) *BElement {
	e.attributes["inert"] = b

	return e
}

func (e *BElement) Inputmode(a BInputmodeEnum) *BElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *BElement) Itemid(s string) *BElement {
	e.attributes["itemid"] = s

	return e
}

func (e *BElement) Itemprop(s ...string) *BElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *BElement) Itemref(s ...string) *BElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *BElement) Itemscope(b bool) *BElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *BElement) Itemtype(s ...string) *BElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *BElement) Lang(s string) *BElement {
	e.attributes["lang"] = s

	return e
}

func (e *BElement) Nonce(s string) *BElement {
	e.attributes["nonce"] = s

	return e
}

func (e *BElement) Popover(s string) *BElement {
	e.attributes["popover"] = s

	return e
}

func (e *BElement) Slot(s string) *BElement {
	e.attributes["slot"] = s

	return e
}

func (e *BElement) Spellcheck(a BSpellcheckEnum) *BElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *BElement) Style(s string) *BElement {
	e.attributes["style"] = s

	return e
}

func (e *BElement) Tabindex(i int) *BElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *BElement) Title(s string) *BElement {
	e.attributes["title"] = s

	return e
}

func (e *BElement) Translate(a BTranslateEnum) *BElement {
	e.attributes["translate"] = a

	return e
}

func (e *BElement) Writingsuggestions(a BWritingsuggestionsEnum) *BElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *BElement) Render(w io.Writer) error {
	indent := strings.Repeat("  ", e.indent)

	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte(indent + "<b")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key))

		// Enum types support empty attributes and can be omitted.
		if fmt.Sprintf("%s", v) == "" {
			w.Write([]byte(" "))
			continue
		}

		w.Write([]byte("="))

		w.Write([]byte("\"" + fmt.Sprintf("%v", v) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">\n")); err != nil {
		return err
	}
	for _, child := range e.children {
		child.AddIndent(e.Indent())
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte(indent + "</b>\n")); err != nil {
		return err
	}

	return nil
}
