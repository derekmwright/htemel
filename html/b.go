// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"strings"

	"github.com/derekmwright/htemel"
	"golang.org/x/net/html"
)

type BElement struct {
	attributes bAttrs
	children   []htemel.Node
	skipRender bool
}

// B creates a tag <b> instance and returns it for further modification.
// Any children passed will be nested within the tag.
//
// Spec Description: The b element represents a span of text to which attention is being drawn for utilitarian purposes without conveying any extra importance and with no implication of an alternate voice or mood, such as key words in a document abstract, product names in a review, actionable words in interactive text-driven software, or an article lede.
func B(children ...htemel.Node) *BElement {
	node := &BElement{
		children:   children,
		attributes: make(bAttrs),
	}

	return node
}

func BIf(condition bool, children ...htemel.Node) *BElement {
	if condition {
		return B(children...)
	}

	return &BElement{
		skipRender: true,
	}
}

type BAutocapitalizeAttrEnum string

const (
	BAutocapitalizeAttrEnumCharacters BAutocapitalizeAttrEnum = "characters"
	BAutocapitalizeAttrEnumNone       BAutocapitalizeAttrEnum = "none"
	BAutocapitalizeAttrEnumOff        BAutocapitalizeAttrEnum = "off"
	BAutocapitalizeAttrEnumOn         BAutocapitalizeAttrEnum = "on"
	BAutocapitalizeAttrEnumSentences  BAutocapitalizeAttrEnum = "sentences"
	BAutocapitalizeAttrEnumWords      BAutocapitalizeAttrEnum = "words"
)

type BAutocorrectAttrEnum string

const (
	BAutocorrectAttrEnumOn  BAutocorrectAttrEnum = "on"
	BAutocorrectAttrEnumOff BAutocorrectAttrEnum = "off"
)

type BContenteditableAttrEnum string

const (
	BContenteditableAttrEnumFalse         BContenteditableAttrEnum = "false"
	BContenteditableAttrEnumPlaintextOnly BContenteditableAttrEnum = "plaintext-only"
	BContenteditableAttrEnumTrue          BContenteditableAttrEnum = "true"
)

type bAttrs map[string]any

func (e *BElement) Autocapitalize(a BAutocapitalizeAttrEnum) *BElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *BElement) Autocorrect(a BAutocorrectAttrEnum) *BElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *BElement) Autofocus(b bool) *BElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *BElement) Class(s ...string) *BElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *BElement) Contenteditable(a BContenteditableAttrEnum) *BElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *BElement) Id(s string) *BElement {
	e.attributes["id"] = s

	return e
}

func (e *BElement) Slot(s string) *BElement {
	e.attributes["slot"] = s

	return e
}

func (e *BElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<b")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key + "="))
		w.Write([]byte("\"" + html.EscapeString(fmt.Sprintf("%v", v)) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}

	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</b>")); err != nil {
		return err
	}

	return nil
}
