// Code generated by htemel. DO NOT EDIT.
package html

import (
  "fmt"
  "github.com/derekmwright/htemel"
  "golang.org/x/net/html"
  "io"
  "strings"
)

type BElement struct {
	attributes bAttrs
	children []htemel.Node
	skipRender bool
}

// B creates a tag <b> instance and returns it for further modification.
// Any children passed will be nested within the tag.
//
// Spec Description: The b element represents a span of text to which attention is being drawn for utilitarian purposes without conveying any extra importance and with no implication of an alternate voice or mood, such as key words in a document abstract, product names in a review, actionable words in interactive text-driven software, or an article lede.
func B(children ...htemel.Node) *BElement {
	node := &BElement{
		children: children,
		attributes: make(bAttrs),
	}

	return node
}

func BIf(condition bool, children ...htemel.Node) *BElement {
	if condition {
		return B(children...)
	}

	return &BElement{
		skipRender: true,
	}
}

type BAutocapitalizeEnum string

const (
	BAutocapitalizeEnumOff BAutocapitalizeEnum = "off"
	BAutocapitalizeEnumOn BAutocapitalizeEnum = "on"
	BAutocapitalizeEnumSentences BAutocapitalizeEnum = "sentences"
	BAutocapitalizeEnumWords BAutocapitalizeEnum = "words"
	BAutocapitalizeEnumCharacters BAutocapitalizeEnum = "characters"
	BAutocapitalizeEnumNone BAutocapitalizeEnum = "none"
)

type BAutocorrectEnum string

const (
	BAutocorrectEnumOff BAutocorrectEnum = "off"
	BAutocorrectEnumOn BAutocorrectEnum = "on"
)

type BContenteditableEnum string

const (
	BContenteditableEnumPlaintextOnly BContenteditableEnum = "plaintext-only"
	BContenteditableEnumTrue BContenteditableEnum = "true"
	BContenteditableEnumFalse BContenteditableEnum = "false"
)

type BDirEnum string

const (
	BDirEnumLtr BDirEnum = "ltr"
	BDirEnumRtl BDirEnum = "rtl"
	BDirEnumAuto BDirEnum = "auto"
)

type BDraggableEnum string

const (
	BDraggableEnumFalse BDraggableEnum = "false"
	BDraggableEnumTrue BDraggableEnum = "true"
)

type BEnterkeyhintEnum string

const (
	BEnterkeyhintEnumPrevious BEnterkeyhintEnum = "previous"
	BEnterkeyhintEnumSearch BEnterkeyhintEnum = "search"
	BEnterkeyhintEnumSend BEnterkeyhintEnum = "send"
	BEnterkeyhintEnumDone BEnterkeyhintEnum = "done"
	BEnterkeyhintEnumEnter BEnterkeyhintEnum = "enter"
	BEnterkeyhintEnumGo BEnterkeyhintEnum = "go"
	BEnterkeyhintEnumNext BEnterkeyhintEnum = "next"
)

type BHiddenEnum string

const (
	BHiddenEnumHidden BHiddenEnum = "hidden"
	BHiddenEnumUntilFound BHiddenEnum = "until-found"
)

type bAttrs map[string]any

func (e *BElement) Autocapitalize(a BAutocapitalizeEnum) *BElement {
	e.attributes["autocapitalize"] = a
	
	return e
}

func (e *BElement) Autocorrect(a BAutocorrectEnum) *BElement {
	e.attributes["autocorrect"] = a
	
	return e
}

func (e *BElement) Autofocus(b bool) *BElement {
	e.attributes["autofocus"] = b
	
	return e
}

func (e *BElement) Class(s ...string) *BElement {
	e.attributes["class"] = strings.Join(s, " ")
	
	return e
}

func (e *BElement) Contenteditable(a BContenteditableEnum) *BElement {
	e.attributes["contenteditable"] = a
	
	return e
}

func (e *BElement) Dir(a BDirEnum) *BElement {
	e.attributes["dir"] = a
	
	return e
}

func (e *BElement) Draggable(a BDraggableEnum) *BElement {
	e.attributes["draggable"] = a
	
	return e
}

func (e *BElement) Enterkeyhint(a BEnterkeyhintEnum) *BElement {
	e.attributes["enterkeyhint"] = a
	
	return e
}

func (e *BElement) Hidden(a BHiddenEnum) *BElement {
	e.attributes["hidden"] = a
	
	return e
}

func (e *BElement) Id(s string) *BElement {
	e.attributes["id"] = s
	
	return e
}

func (e *BElement) Slot(s string) *BElement {
	e.attributes["slot"] = s
	
	return e
}

func (e *BElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<b")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key + "="))
		w.Write([]byte("\"" + html.EscapeString(fmt.Sprintf("%v", v)) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}

	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</b>")); err != nil {
		return err
	}

	return nil
}
