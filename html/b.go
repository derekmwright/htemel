// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"slices"
	"strings"

	"github.com/go-htemel/htemel"
	"golang.org/x/net/html"
)

type BElement struct {
	attributes bAttrs
	children   []htemel.Node
	skipRender bool
}

// B creates a tag <b> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The b element represents a span of text to which attention is being drawn for utilitarian purposes without conveying any extra importance and with no implication of an alternate voice or mood, such as key words in a document abstract, product names in a review, actionable words in interactive text-driven software, or an article lede.
func B(children ...htemel.Node) *BElement {
	node := &BElement{
		children:   children,
		attributes: make(bAttrs),
	}

	return node
}

func BIf(condition bool, children ...htemel.Node) *BElement {
	if condition {
		return B(children...)
	}

	return &BElement{
		children:   children,
		attributes: make(bAttrs),
		skipRender: true,
	}
}

func BTernary(condition bool, true htemel.Node, false htemel.Node) *BElement {
	if condition {
		return B(true)
	}
	return B(false)
}

// Children appends children to this element.
func (e *BElement) Children(children ...htemel.Node) *BElement {
	e.children = append(e.children, children...)
	return e
}

// With allows passing a function to modify the element via a closure.
func (e *BElement) With(fn func(*BElement)) *BElement {
	fn(e)
	return e
}

// Text adds a text node to the element.
func (e *BElement) Text(text string) *BElement {
	return e.Children(htemel.Text(text))
}

// Textf adds a text node to the element with the given format string and arguments.
func (e *BElement) Textf(format string, args ...any) *BElement {
	return e.Children(htemel.Text(fmt.Sprintf(format, args...)))
}

// If conditionally adds a child node to the element if the condition is true, otherwise it is a no-op.
func (e *BElement) If(cond bool, child htemel.Node) *BElement {
	if cond {
		return e.Children(child)
	}
	return e
}

func (e *BElement) IfElse(cond bool, then, els htemel.Node) *BElement {
	if cond {
		e.Children(then)
	} else {
		e.Children(els)
	}
	return e
}

// IfThen conditionally calls the given function with the element if the condition is true, otherwise it is a no-op.
func (e *BElement) IfThen(cond bool, fn func(*BElement)) *BElement {
	if cond {
		fn(e)
	}
	return e
}

// AddClass appends a class to the element.
func (e *BElement) AddClass(classes ...string) *BElement {
	current := e.attributes["class"].(string)
	all := append(strings.Fields(current), classes...)
	e.attributes["class"] = strings.Join(all, " ")
	return e
}

// ToggleClass toggles a class on or off.
func (e *BElement) ToggleClass(class string, enable bool) *BElement {
	classes := strings.Fields(e.attributes["class"].(string))
	idx := slices.Index(classes, class)
	if enable && idx == -1 {
		classes = append(classes, class)
	} else if !enable && idx >= 0 {
		classes = slices.Delete(classes, idx, idx+1)
	}
	e.attributes["class"] = strings.Join(classes, " ")
	return e
}

type BAutocapitalize string

const (
	BAutocapitalizeOn         BAutocapitalize = "on"
	BAutocapitalizeSentences  BAutocapitalize = "sentences"
	BAutocapitalizeWords      BAutocapitalize = "words"
	BAutocapitalizeCharacters BAutocapitalize = "characters"
	BAutocapitalizeNone       BAutocapitalize = "none"
	BAutocapitalizeOff        BAutocapitalize = "off"
)

type BAutocorrect string

const (
	BAutocorrectOff   BAutocorrect = "off"
	BAutocorrectOn    BAutocorrect = "on"
	BAutocorrectEmpty BAutocorrect = ""
)

type BContenteditable string

const (
	BContenteditableFalse         BContenteditable = "false"
	BContenteditablePlaintextOnly BContenteditable = "plaintext-only"
	BContenteditableTrue          BContenteditable = "true"
	BContenteditableEmpty         BContenteditable = ""
)

type BDir string

const (
	BDirAuto BDir = "auto"
	BDirLtr  BDir = "ltr"
	BDirRtl  BDir = "rtl"
)

type BDraggable string

const (
	BDraggableFalse BDraggable = "false"
	BDraggableTrue  BDraggable = "true"
)

type BEnterkeyhint string

const (
	BEnterkeyhintGo       BEnterkeyhint = "go"
	BEnterkeyhintNext     BEnterkeyhint = "next"
	BEnterkeyhintPrevious BEnterkeyhint = "previous"
	BEnterkeyhintSearch   BEnterkeyhint = "search"
	BEnterkeyhintSend     BEnterkeyhint = "send"
	BEnterkeyhintDone     BEnterkeyhint = "done"
	BEnterkeyhintEnter    BEnterkeyhint = "enter"
)

type BHidden string

const (
	BHiddenHidden     BHidden = "hidden"
	BHiddenUntilFound BHidden = "until-found"
	BHiddenEmpty      BHidden = ""
)

type BInputmode string

const (
	BInputmodeEmail   BInputmode = "email"
	BInputmodeNone    BInputmode = "none"
	BInputmodeNumeric BInputmode = "numeric"
	BInputmodeSearch  BInputmode = "search"
	BInputmodeTel     BInputmode = "tel"
	BInputmodeText    BInputmode = "text"
	BInputmodeUrl     BInputmode = "url"
	BInputmodeDecimal BInputmode = "decimal"
)

type BSpellcheck string

const (
	BSpellcheckTrue  BSpellcheck = "true"
	BSpellcheckFalse BSpellcheck = "false"
	BSpellcheckEmpty BSpellcheck = ""
)

type BTranslate string

const (
	BTranslateYes   BTranslate = "yes"
	BTranslateNo    BTranslate = "no"
	BTranslateEmpty BTranslate = ""
)

type BWritingsuggestions string

const (
	BWritingsuggestionsFalse BWritingsuggestions = "false"
	BWritingsuggestionsTrue  BWritingsuggestions = "true"
	BWritingsuggestionsEmpty BWritingsuggestions = ""
)

type bAttrs map[string]any

func (e *BElement) AriaUnsafe(name string, s string) *BElement {
	tag := strings.ToLower("aria-" + name)

	e.attributes[tag] = s

	return e
}

func (e *BElement) Aria(name string, s string) *BElement {
	return e.AriaUnsafe(name, html.EscapeString(s))
}

func (e *BElement) Autocapitalize(a BAutocapitalize) *BElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *BElement) Autocorrect(a BAutocorrect) *BElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *BElement) Autofocus(b bool) *BElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *BElement) Class(s ...string) *BElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *BElement) Contenteditable(a BContenteditable) *BElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *BElement) DataUnsafe(name string, s string) *BElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *BElement) Data(name string, s string) *BElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *BElement) Dir(a BDir) *BElement {
	e.attributes["dir"] = a

	return e
}

func (e *BElement) Draggable(a BDraggable) *BElement {
	e.attributes["draggable"] = a

	return e
}

func (e *BElement) Enterkeyhint(a BEnterkeyhint) *BElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *BElement) Hidden(a BHidden) *BElement {
	e.attributes["hidden"] = a

	return e
}

func (e *BElement) Id(s string) *BElement {
	e.attributes["id"] = s

	return e
}

func (e *BElement) Inert(b bool) *BElement {
	e.attributes["inert"] = b

	return e
}

func (e *BElement) Inputmode(a BInputmode) *BElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *BElement) Itemid(s string) *BElement {
	e.attributes["itemid"] = s

	return e
}

func (e *BElement) Itemprop(s ...string) *BElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *BElement) Itemref(s ...string) *BElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *BElement) Itemscope(b bool) *BElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *BElement) Itemtype(s ...string) *BElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *BElement) Lang(s string) *BElement {
	e.attributes["lang"] = s

	return e
}

func (e *BElement) Nonce(s string) *BElement {
	e.attributes["nonce"] = s

	return e
}

func (e *BElement) Popover(s string) *BElement {
	e.attributes["popover"] = s

	return e
}

func (e *BElement) Role(s string) *BElement {
	e.attributes["role"] = s

	return e
}

func (e *BElement) Slot(s string) *BElement {
	e.attributes["slot"] = s

	return e
}

func (e *BElement) Spellcheck(a BSpellcheck) *BElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *BElement) Style(s string) *BElement {
	e.attributes["style"] = s

	return e
}

func (e *BElement) Tabindex(i int) *BElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *BElement) Title(s string) *BElement {
	e.attributes["title"] = s

	return e
}

func (e *BElement) Translate(a BTranslate) *BElement {
	e.attributes["translate"] = a

	return e
}

func (e *BElement) Writingsuggestions(a BWritingsuggestions) *BElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *BElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	var sb strings.Builder
	sb.WriteString("<b")

	for key, v := range e.attributes {
		sb.WriteByte(' ')
		sb.WriteString(key)

		strVal := fmt.Sprintf("%v", v)
		if strVal != "" {
			sb.WriteByte('=')
			sb.WriteByte('"')
			sb.WriteString(strVal)
			sb.WriteByte('"')
		}
	}

	sb.WriteByte('>')
	for _, child := range e.children {
		if err := child.Render(&sb); err != nil {
			return err
		}
	}

	sb.WriteString("</b>")

	_, err := io.WriteString(w, sb.String())
	return err
}
