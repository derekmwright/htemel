// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"slices"
	"strings"

	"github.com/derekmwright/htemel"
	"golang.org/x/net/html"
)

type SummaryElement struct {
	attributes summaryAttrs
	children   []htemel.Node
	skipRender bool
}

// Summary creates a tag <summary> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The summary element represents a summary, caption, or legend for the rest of the contents of the summary element's parent details element, if any.
func Summary(children ...htemel.Node) *SummaryElement {
	node := &SummaryElement{
		children:   children,
		attributes: make(summaryAttrs),
	}

	return node
}

func SummaryIf(condition bool, children ...htemel.Node) *SummaryElement {
	if condition {
		return Summary(children...)
	}

	return &SummaryElement{
		children:   children,
		attributes: make(summaryAttrs),
		skipRender: true,
	}
}

func SummaryTernary(condition bool, true htemel.Node, false htemel.Node) *SummaryElement {
	if condition {
		return Summary(true)
	}
	return Summary(false)
}

// Children appends children to this element.
func (e *SummaryElement) Children(children ...htemel.Node) *SummaryElement {
	e.children = append(e.children, children...)
	return e
}

// With allows passing a function to modify the element via a closure.
func (e *SummaryElement) With(fn func(*SummaryElement)) *SummaryElement {
	fn(e)
	return e
}

// Textf adds a text node to the element with the given format string and arguments.
func (e *SummaryElement) Textf(format string, args ...any) *SummaryElement {
	return e.Children(htemel.Text(fmt.Sprintf(format, args...)))
}

// AddClass appends a class to the element.
func (e *SummaryElement) AddClass(classes ...string) *SummaryElement {
	current := e.attributes["class"].(string)
	all := append(strings.Fields(current), classes...)
	e.attributes["class"] = strings.Join(all, " ")
	return e
}

// ToggleClass toggles a class on or off.
func (e *SummaryElement) ToggleClass(class string, enable bool) *SummaryElement {
	classes := strings.Fields(e.attributes["class"].(string))
	idx := slices.Index(classes, class)
	if enable && idx == -1 {
		classes = append(classes, class)
	} else if !enable && idx >= 0 {
		classes = slices.Delete(classes, idx, idx+1)
	}
	e.attributes["class"] = strings.Join(classes, " ")
	return e
}

type SummaryAutocapitalize string

const (
	SummaryAutocapitalizeNone       SummaryAutocapitalize = "none"
	SummaryAutocapitalizeOff        SummaryAutocapitalize = "off"
	SummaryAutocapitalizeOn         SummaryAutocapitalize = "on"
	SummaryAutocapitalizeSentences  SummaryAutocapitalize = "sentences"
	SummaryAutocapitalizeWords      SummaryAutocapitalize = "words"
	SummaryAutocapitalizeCharacters SummaryAutocapitalize = "characters"
)

type SummaryAutocorrect string

const (
	SummaryAutocorrectOff   SummaryAutocorrect = "off"
	SummaryAutocorrectOn    SummaryAutocorrect = "on"
	SummaryAutocorrectEmpty SummaryAutocorrect = ""
)

type SummaryContenteditable string

const (
	SummaryContenteditableFalse         SummaryContenteditable = "false"
	SummaryContenteditablePlaintextOnly SummaryContenteditable = "plaintext-only"
	SummaryContenteditableTrue          SummaryContenteditable = "true"
	SummaryContenteditableEmpty         SummaryContenteditable = ""
)

type SummaryDir string

const (
	SummaryDirAuto SummaryDir = "auto"
	SummaryDirLtr  SummaryDir = "ltr"
	SummaryDirRtl  SummaryDir = "rtl"
)

type SummaryDraggable string

const (
	SummaryDraggableFalse SummaryDraggable = "false"
	SummaryDraggableTrue  SummaryDraggable = "true"
)

type SummaryEnterkeyhint string

const (
	SummaryEnterkeyhintEnter    SummaryEnterkeyhint = "enter"
	SummaryEnterkeyhintGo       SummaryEnterkeyhint = "go"
	SummaryEnterkeyhintNext     SummaryEnterkeyhint = "next"
	SummaryEnterkeyhintPrevious SummaryEnterkeyhint = "previous"
	SummaryEnterkeyhintSearch   SummaryEnterkeyhint = "search"
	SummaryEnterkeyhintSend     SummaryEnterkeyhint = "send"
	SummaryEnterkeyhintDone     SummaryEnterkeyhint = "done"
)

type SummaryHidden string

const (
	SummaryHiddenUntilFound SummaryHidden = "until-found"
	SummaryHiddenHidden     SummaryHidden = "hidden"
	SummaryHiddenEmpty      SummaryHidden = ""
)

type SummaryInputmode string

const (
	SummaryInputmodeDecimal SummaryInputmode = "decimal"
	SummaryInputmodeEmail   SummaryInputmode = "email"
	SummaryInputmodeNone    SummaryInputmode = "none"
	SummaryInputmodeNumeric SummaryInputmode = "numeric"
	SummaryInputmodeSearch  SummaryInputmode = "search"
	SummaryInputmodeTel     SummaryInputmode = "tel"
	SummaryInputmodeText    SummaryInputmode = "text"
	SummaryInputmodeUrl     SummaryInputmode = "url"
)

type SummarySpellcheck string

const (
	SummarySpellcheckFalse SummarySpellcheck = "false"
	SummarySpellcheckTrue  SummarySpellcheck = "true"
	SummarySpellcheckEmpty SummarySpellcheck = ""
)

type SummaryTranslate string

const (
	SummaryTranslateNo    SummaryTranslate = "no"
	SummaryTranslateYes   SummaryTranslate = "yes"
	SummaryTranslateEmpty SummaryTranslate = ""
)

type SummaryWritingsuggestions string

const (
	SummaryWritingsuggestionsFalse SummaryWritingsuggestions = "false"
	SummaryWritingsuggestionsTrue  SummaryWritingsuggestions = "true"
	SummaryWritingsuggestionsEmpty SummaryWritingsuggestions = ""
)

type summaryAttrs map[string]any

func (e *SummaryElement) AriaUnsafe(name string, s string) *SummaryElement {
	tag := strings.ToLower("aria-" + name)

	e.attributes[tag] = s

	return e
}

func (e *SummaryElement) Aria(name string, s string) *SummaryElement {
	return e.AriaUnsafe(name, html.EscapeString(s))
}

func (e *SummaryElement) Autocapitalize(a SummaryAutocapitalize) *SummaryElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *SummaryElement) Autocorrect(a SummaryAutocorrect) *SummaryElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *SummaryElement) Autofocus(b bool) *SummaryElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *SummaryElement) Class(s ...string) *SummaryElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *SummaryElement) Contenteditable(a SummaryContenteditable) *SummaryElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *SummaryElement) DataUnsafe(name string, s string) *SummaryElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *SummaryElement) Data(name string, s string) *SummaryElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *SummaryElement) Dir(a SummaryDir) *SummaryElement {
	e.attributes["dir"] = a

	return e
}

func (e *SummaryElement) Draggable(a SummaryDraggable) *SummaryElement {
	e.attributes["draggable"] = a

	return e
}

func (e *SummaryElement) Enterkeyhint(a SummaryEnterkeyhint) *SummaryElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *SummaryElement) Hidden(a SummaryHidden) *SummaryElement {
	e.attributes["hidden"] = a

	return e
}

func (e *SummaryElement) Id(s string) *SummaryElement {
	e.attributes["id"] = s

	return e
}

func (e *SummaryElement) Inert(b bool) *SummaryElement {
	e.attributes["inert"] = b

	return e
}

func (e *SummaryElement) Inputmode(a SummaryInputmode) *SummaryElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *SummaryElement) Itemid(s string) *SummaryElement {
	e.attributes["itemid"] = s

	return e
}

func (e *SummaryElement) Itemprop(s ...string) *SummaryElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *SummaryElement) Itemref(s ...string) *SummaryElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *SummaryElement) Itemscope(b bool) *SummaryElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *SummaryElement) Itemtype(s ...string) *SummaryElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *SummaryElement) Lang(s string) *SummaryElement {
	e.attributes["lang"] = s

	return e
}

func (e *SummaryElement) Nonce(s string) *SummaryElement {
	e.attributes["nonce"] = s

	return e
}

func (e *SummaryElement) Popover(s string) *SummaryElement {
	e.attributes["popover"] = s

	return e
}

func (e *SummaryElement) Role(s string) *SummaryElement {
	e.attributes["role"] = s

	return e
}

func (e *SummaryElement) Slot(s string) *SummaryElement {
	e.attributes["slot"] = s

	return e
}

func (e *SummaryElement) Spellcheck(a SummarySpellcheck) *SummaryElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *SummaryElement) Style(s string) *SummaryElement {
	e.attributes["style"] = s

	return e
}

func (e *SummaryElement) Tabindex(i int) *SummaryElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *SummaryElement) Title(s string) *SummaryElement {
	e.attributes["title"] = s

	return e
}

func (e *SummaryElement) Translate(a SummaryTranslate) *SummaryElement {
	e.attributes["translate"] = a

	return e
}

func (e *SummaryElement) Writingsuggestions(a SummaryWritingsuggestions) *SummaryElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *SummaryElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<summary")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key))

		// Enum types support empty attributes and can be omitted.
		if fmt.Sprintf("%s", v) == "" {
			w.Write([]byte(" "))
			continue
		}

		w.Write([]byte("="))

		w.Write([]byte("\"" + fmt.Sprintf("%v", v) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}
	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</summary>")); err != nil {
		return err
	}

	return nil
}
