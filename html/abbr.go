// Code generated by htemel. DO NOT EDIT.
package html

import (
  "fmt"
  "github.com/derekmwright/htemel"
  "golang.org/x/net/html"
  "io"
  "strings"
)

type AbbrElement struct {
	attributes abbrAttrs
	children []htemel.Node
	skipRender bool
}

// Abbr creates a tag <abbr> instance and returns it for further modification.
// Any children passed will be nested within the tag.
//
// Spec Description: The abbr element represents an abbreviation or acronym, optionally with its expansion. The title attribute may be used to provide an expansion of the abbreviation. The attribute, if specified, must contain an expansion of the abbreviation, and nothing else.
func Abbr(children ...htemel.Node) *AbbrElement {
	node := &AbbrElement{
		children: children,
		attributes: make(abbrAttrs),
	}

	return node
}

func AbbrIf(condition bool, children ...htemel.Node) *AbbrElement {
	if condition {
		return Abbr(children...)
	}

	return &AbbrElement{
		skipRender: true,
	}
}

type AbbrAutocapitalizeEnum string

const (
	AbbrAutocapitalizeEnumCharacters AbbrAutocapitalizeEnum = "characters"
	AbbrAutocapitalizeEnumNone AbbrAutocapitalizeEnum = "none"
	AbbrAutocapitalizeEnumOff AbbrAutocapitalizeEnum = "off"
	AbbrAutocapitalizeEnumOn AbbrAutocapitalizeEnum = "on"
	AbbrAutocapitalizeEnumSentences AbbrAutocapitalizeEnum = "sentences"
	AbbrAutocapitalizeEnumWords AbbrAutocapitalizeEnum = "words"
)

type AbbrAutocorrectEnum string

const (
	AbbrAutocorrectEnumOff AbbrAutocorrectEnum = "off"
	AbbrAutocorrectEnumOn AbbrAutocorrectEnum = "on"
)

type AbbrContenteditableEnum string

const (
	AbbrContenteditableEnumFalse AbbrContenteditableEnum = "false"
	AbbrContenteditableEnumPlaintextOnly AbbrContenteditableEnum = "plaintext-only"
	AbbrContenteditableEnumTrue AbbrContenteditableEnum = "true"
)

type AbbrDirEnum string

const (
	AbbrDirEnumRtl AbbrDirEnum = "rtl"
	AbbrDirEnumAuto AbbrDirEnum = "auto"
	AbbrDirEnumLtr AbbrDirEnum = "ltr"
)

type AbbrDraggableEnum string

const (
	AbbrDraggableEnumFalse AbbrDraggableEnum = "false"
	AbbrDraggableEnumTrue AbbrDraggableEnum = "true"
)

type AbbrEnterkeyhintEnum string

const (
	AbbrEnterkeyhintEnumSearch AbbrEnterkeyhintEnum = "search"
	AbbrEnterkeyhintEnumSend AbbrEnterkeyhintEnum = "send"
	AbbrEnterkeyhintEnumDone AbbrEnterkeyhintEnum = "done"
	AbbrEnterkeyhintEnumEnter AbbrEnterkeyhintEnum = "enter"
	AbbrEnterkeyhintEnumGo AbbrEnterkeyhintEnum = "go"
	AbbrEnterkeyhintEnumNext AbbrEnterkeyhintEnum = "next"
	AbbrEnterkeyhintEnumPrevious AbbrEnterkeyhintEnum = "previous"
)

type AbbrHiddenEnum string

const (
	AbbrHiddenEnumHidden AbbrHiddenEnum = "hidden"
	AbbrHiddenEnumUntilFound AbbrHiddenEnum = "until-found"
)

type abbrAttrs map[string]any

func (e *AbbrElement) Autocapitalize(a AbbrAutocapitalizeEnum) *AbbrElement {
	e.attributes["autocapitalize"] = a
	
	return e
}

func (e *AbbrElement) Autocorrect(a AbbrAutocorrectEnum) *AbbrElement {
	e.attributes["autocorrect"] = a
	
	return e
}

func (e *AbbrElement) Autofocus(b bool) *AbbrElement {
	e.attributes["autofocus"] = b
	
	return e
}

func (e *AbbrElement) Class(s ...string) *AbbrElement {
	e.attributes["class"] = strings.Join(s, " ")
	
	return e
}

func (e *AbbrElement) Contenteditable(a AbbrContenteditableEnum) *AbbrElement {
	e.attributes["contenteditable"] = a
	
	return e
}

func (e *AbbrElement) Dir(a AbbrDirEnum) *AbbrElement {
	e.attributes["dir"] = a
	
	return e
}

func (e *AbbrElement) Draggable(a AbbrDraggableEnum) *AbbrElement {
	e.attributes["draggable"] = a
	
	return e
}

func (e *AbbrElement) Enterkeyhint(a AbbrEnterkeyhintEnum) *AbbrElement {
	e.attributes["enterkeyhint"] = a
	
	return e
}

func (e *AbbrElement) Hidden(a AbbrHiddenEnum) *AbbrElement {
	e.attributes["hidden"] = a
	
	return e
}

func (e *AbbrElement) Id(s string) *AbbrElement {
	e.attributes["id"] = s
	
	return e
}

func (e *AbbrElement) Slot(s string) *AbbrElement {
	e.attributes["slot"] = s
	
	return e
}

func (e *AbbrElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<abbr")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key + "="))
		w.Write([]byte("\"" + html.EscapeString(fmt.Sprintf("%v", v)) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}

	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</abbr>")); err != nil {
		return err
	}

	return nil
}
