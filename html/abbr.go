// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"strings"

	"github.com/derekmwright/htemel"
	"golang.org/x/net/html"
)

type AbbrElement struct {
	attributes abbrAttrs
	children   []htemel.Node
	skipRender bool
}

// Abbr creates a tag <abbr> instance and returns it for further modification.
// Any children passed will be nested within the tag.
//
// Spec Description: The abbr element represents an abbreviation or acronym, optionally with its expansion. The title attribute may be used to provide an expansion of the abbreviation. The attribute, if specified, must contain an expansion of the abbreviation, and nothing else.
func Abbr(children ...htemel.Node) *AbbrElement {
	node := &AbbrElement{
		children:   children,
		attributes: make(abbrAttrs),
	}

	return node
}

func AbbrIf(condition bool, children ...htemel.Node) *AbbrElement {
	if condition {
		return Abbr(children...)
	}

	return &AbbrElement{
		skipRender: true,
	}
}

func AbbrTernary(condition bool, true htemel.Node, false htemel.Node) *AbbrElement {
	if condition {
		return Abbr(true)
	}

	return Abbr(false)
}

type AbbrAutocapitalizeEnum string

const (
	AbbrAutocapitalizeEnumNone       AbbrAutocapitalizeEnum = "none"
	AbbrAutocapitalizeEnumOff        AbbrAutocapitalizeEnum = "off"
	AbbrAutocapitalizeEnumOn         AbbrAutocapitalizeEnum = "on"
	AbbrAutocapitalizeEnumSentences  AbbrAutocapitalizeEnum = "sentences"
	AbbrAutocapitalizeEnumWords      AbbrAutocapitalizeEnum = "words"
	AbbrAutocapitalizeEnumCharacters AbbrAutocapitalizeEnum = "characters"
)

type AbbrAutocorrectEnum string

const (
	AbbrAutocorrectEnumOff   AbbrAutocorrectEnum = "off"
	AbbrAutocorrectEnumOn    AbbrAutocorrectEnum = "on"
	AbbrAutocorrectEnumEmpty AbbrAutocorrectEnum = ""
)

type AbbrContenteditableEnum string

const (
	AbbrContenteditableEnumPlaintextOnly AbbrContenteditableEnum = "plaintext-only"
	AbbrContenteditableEnumTrue          AbbrContenteditableEnum = "true"
	AbbrContenteditableEnumFalse         AbbrContenteditableEnum = "false"
	AbbrContenteditableEnumEmpty         AbbrContenteditableEnum = ""
)

type AbbrDirEnum string

const (
	AbbrDirEnumAuto AbbrDirEnum = "auto"
	AbbrDirEnumLtr  AbbrDirEnum = "ltr"
	AbbrDirEnumRtl  AbbrDirEnum = "rtl"
)

type AbbrDraggableEnum string

const (
	AbbrDraggableEnumFalse AbbrDraggableEnum = "false"
	AbbrDraggableEnumTrue  AbbrDraggableEnum = "true"
)

type AbbrEnterkeyhintEnum string

const (
	AbbrEnterkeyhintEnumDone     AbbrEnterkeyhintEnum = "done"
	AbbrEnterkeyhintEnumEnter    AbbrEnterkeyhintEnum = "enter"
	AbbrEnterkeyhintEnumGo       AbbrEnterkeyhintEnum = "go"
	AbbrEnterkeyhintEnumNext     AbbrEnterkeyhintEnum = "next"
	AbbrEnterkeyhintEnumPrevious AbbrEnterkeyhintEnum = "previous"
	AbbrEnterkeyhintEnumSearch   AbbrEnterkeyhintEnum = "search"
	AbbrEnterkeyhintEnumSend     AbbrEnterkeyhintEnum = "send"
)

type AbbrHiddenEnum string

const (
	AbbrHiddenEnumUntilFound AbbrHiddenEnum = "until-found"
	AbbrHiddenEnumHidden     AbbrHiddenEnum = "hidden"
	AbbrHiddenEnumEmpty      AbbrHiddenEnum = ""
)

type AbbrInputmodeEnum string

const (
	AbbrInputmodeEnumNumeric AbbrInputmodeEnum = "numeric"
	AbbrInputmodeEnumSearch  AbbrInputmodeEnum = "search"
	AbbrInputmodeEnumTel     AbbrInputmodeEnum = "tel"
	AbbrInputmodeEnumText    AbbrInputmodeEnum = "text"
	AbbrInputmodeEnumUrl     AbbrInputmodeEnum = "url"
	AbbrInputmodeEnumDecimal AbbrInputmodeEnum = "decimal"
	AbbrInputmodeEnumEmail   AbbrInputmodeEnum = "email"
	AbbrInputmodeEnumNone    AbbrInputmodeEnum = "none"
)

type AbbrSpellcheckEnum string

const (
	AbbrSpellcheckEnumFalse AbbrSpellcheckEnum = "false"
	AbbrSpellcheckEnumTrue  AbbrSpellcheckEnum = "true"
	AbbrSpellcheckEnumEmpty AbbrSpellcheckEnum = ""
)

type AbbrTranslateEnum string

const (
	AbbrTranslateEnumNo    AbbrTranslateEnum = "no"
	AbbrTranslateEnumYes   AbbrTranslateEnum = "yes"
	AbbrTranslateEnumEmpty AbbrTranslateEnum = ""
)

type AbbrWritingsuggestionsEnum string

const (
	AbbrWritingsuggestionsEnumFalse AbbrWritingsuggestionsEnum = "false"
	AbbrWritingsuggestionsEnumTrue  AbbrWritingsuggestionsEnum = "true"
	AbbrWritingsuggestionsEnumEmpty AbbrWritingsuggestionsEnum = ""
)

type abbrAttrs map[string]any

func (e *AbbrElement) Autocapitalize(a AbbrAutocapitalizeEnum) *AbbrElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *AbbrElement) Autocorrect(a AbbrAutocorrectEnum) *AbbrElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *AbbrElement) Autofocus(b bool) *AbbrElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *AbbrElement) Class(s ...string) *AbbrElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *AbbrElement) Contenteditable(a AbbrContenteditableEnum) *AbbrElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *AbbrElement) DataUnsafe(name string, s string) *AbbrElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *AbbrElement) Data(name string, s string) *AbbrElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *AbbrElement) Dir(a AbbrDirEnum) *AbbrElement {
	e.attributes["dir"] = a

	return e
}

func (e *AbbrElement) Draggable(a AbbrDraggableEnum) *AbbrElement {
	e.attributes["draggable"] = a

	return e
}

func (e *AbbrElement) Enterkeyhint(a AbbrEnterkeyhintEnum) *AbbrElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *AbbrElement) Hidden(a AbbrHiddenEnum) *AbbrElement {
	e.attributes["hidden"] = a

	return e
}

func (e *AbbrElement) Id(s string) *AbbrElement {
	e.attributes["id"] = s

	return e
}

func (e *AbbrElement) Inert(b bool) *AbbrElement {
	e.attributes["inert"] = b

	return e
}

func (e *AbbrElement) Inputmode(a AbbrInputmodeEnum) *AbbrElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *AbbrElement) Itemid(s string) *AbbrElement {
	e.attributes["itemid"] = s

	return e
}

func (e *AbbrElement) Itemprop(s ...string) *AbbrElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *AbbrElement) Itemref(s ...string) *AbbrElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *AbbrElement) Itemscope(b bool) *AbbrElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *AbbrElement) Itemtype(s ...string) *AbbrElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *AbbrElement) Lang(s string) *AbbrElement {
	e.attributes["lang"] = s

	return e
}

func (e *AbbrElement) Nonce(s string) *AbbrElement {
	e.attributes["nonce"] = s

	return e
}

func (e *AbbrElement) Popover(s string) *AbbrElement {
	e.attributes["popover"] = s

	return e
}

func (e *AbbrElement) Slot(s string) *AbbrElement {
	e.attributes["slot"] = s

	return e
}

func (e *AbbrElement) Spellcheck(a AbbrSpellcheckEnum) *AbbrElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *AbbrElement) Style(s string) *AbbrElement {
	e.attributes["style"] = s

	return e
}

func (e *AbbrElement) Tabindex(i int) *AbbrElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *AbbrElement) Title(s string) *AbbrElement {
	e.attributes["title"] = s

	return e
}

func (e *AbbrElement) Translate(a AbbrTranslateEnum) *AbbrElement {
	e.attributes["translate"] = a

	return e
}

func (e *AbbrElement) Writingsuggestions(a AbbrWritingsuggestionsEnum) *AbbrElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *AbbrElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<abbr")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key))

		// Enum types support empty attributes and can be omitted.
		if fmt.Sprintf("%s", v) == "" {
			w.Write([]byte(" "))
			continue
		}

		w.Write([]byte("="))

		w.Write([]byte("\"" + fmt.Sprintf("%v", v) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}

	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</abbr>")); err != nil {
		return err
	}

	return nil
}
