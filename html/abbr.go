// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"slices"
	"strings"

	"github.com/go-htemel/htemel"
	"golang.org/x/net/html"
)

type AbbrElement struct {
	attributes abbrAttrs
	children   []htemel.Node
	skipRender bool
}

// Abbr creates a tag <abbr> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The abbr element represents an abbreviation or acronym, optionally with its expansion. The title attribute may be used to provide an expansion of the abbreviation. The attribute, if specified, must contain an expansion of the abbreviation, and nothing else.
func Abbr(children ...htemel.Node) *AbbrElement {
	node := &AbbrElement{
		children:   children,
		attributes: make(abbrAttrs),
	}

	return node
}

func AbbrIf(condition bool, children ...htemel.Node) *AbbrElement {
	if condition {
		return Abbr(children...)
	}

	return &AbbrElement{
		children:   children,
		attributes: make(abbrAttrs),
		skipRender: true,
	}
}

func AbbrTernary(condition bool, true htemel.Node, false htemel.Node) *AbbrElement {
	if condition {
		return Abbr(true)
	}
	return Abbr(false)
}

// Children appends children to this element.
func (e *AbbrElement) Children(children ...htemel.Node) *AbbrElement {
	e.children = append(e.children, children...)
	return e
}

// With allows passing a function to modify the element via a closure.
func (e *AbbrElement) With(fn func(*AbbrElement)) *AbbrElement {
	fn(e)
	return e
}

// Text adds a text node to the element.
func (e *AbbrElement) Text(text string) *AbbrElement {
	return e.Children(htemel.Text(text))
}

// Textf adds a text node to the element with the given format string and arguments.
func (e *AbbrElement) Textf(format string, args ...any) *AbbrElement {
	return e.Children(htemel.Text(fmt.Sprintf(format, args...)))
}

// If conditionally adds a child node to the element if the condition is true, otherwise it is a no-op.
func (e *AbbrElement) If(cond bool, child htemel.Node) *AbbrElement {
	if cond {
		return e.Children(child)
	}
	return e
}

func (e *AbbrElement) IfElse(cond bool, then, els htemel.Node) *AbbrElement {
	if cond {
		e.Children(then)
	} else {
		e.Children(els)
	}
	return e
}

// IfThen conditionally calls the given function with the element if the condition is true, otherwise it is a no-op.
func (e *AbbrElement) IfThen(cond bool, fn func(*AbbrElement)) *AbbrElement {
	if cond {
		fn(e)
	}
	return e
}

// AddClass appends a class to the element.
func (e *AbbrElement) AddClass(classes ...string) *AbbrElement {
	current := e.attributes["class"].(string)
	all := append(strings.Fields(current), classes...)
	e.attributes["class"] = strings.Join(all, " ")
	return e
}

// ToggleClass toggles a class on or off.
func (e *AbbrElement) ToggleClass(class string, enable bool) *AbbrElement {
	classes := strings.Fields(e.attributes["class"].(string))
	idx := slices.Index(classes, class)
	if enable && idx == -1 {
		classes = append(classes, class)
	} else if !enable && idx >= 0 {
		classes = slices.Delete(classes, idx, idx+1)
	}
	e.attributes["class"] = strings.Join(classes, " ")
	return e
}

type AbbrAutocapitalize string

const (
	AbbrAutocapitalizeOn         AbbrAutocapitalize = "on"
	AbbrAutocapitalizeSentences  AbbrAutocapitalize = "sentences"
	AbbrAutocapitalizeWords      AbbrAutocapitalize = "words"
	AbbrAutocapitalizeCharacters AbbrAutocapitalize = "characters"
	AbbrAutocapitalizeNone       AbbrAutocapitalize = "none"
	AbbrAutocapitalizeOff        AbbrAutocapitalize = "off"
)

type AbbrAutocorrect string

const (
	AbbrAutocorrectOff   AbbrAutocorrect = "off"
	AbbrAutocorrectOn    AbbrAutocorrect = "on"
	AbbrAutocorrectEmpty AbbrAutocorrect = ""
)

type AbbrContenteditable string

const (
	AbbrContenteditableFalse         AbbrContenteditable = "false"
	AbbrContenteditablePlaintextOnly AbbrContenteditable = "plaintext-only"
	AbbrContenteditableTrue          AbbrContenteditable = "true"
	AbbrContenteditableEmpty         AbbrContenteditable = ""
)

type AbbrDir string

const (
	AbbrDirAuto AbbrDir = "auto"
	AbbrDirLtr  AbbrDir = "ltr"
	AbbrDirRtl  AbbrDir = "rtl"
)

type AbbrDraggable string

const (
	AbbrDraggableFalse AbbrDraggable = "false"
	AbbrDraggableTrue  AbbrDraggable = "true"
)

type AbbrEnterkeyhint string

const (
	AbbrEnterkeyhintSend     AbbrEnterkeyhint = "send"
	AbbrEnterkeyhintDone     AbbrEnterkeyhint = "done"
	AbbrEnterkeyhintEnter    AbbrEnterkeyhint = "enter"
	AbbrEnterkeyhintGo       AbbrEnterkeyhint = "go"
	AbbrEnterkeyhintNext     AbbrEnterkeyhint = "next"
	AbbrEnterkeyhintPrevious AbbrEnterkeyhint = "previous"
	AbbrEnterkeyhintSearch   AbbrEnterkeyhint = "search"
)

type AbbrHidden string

const (
	AbbrHiddenHidden     AbbrHidden = "hidden"
	AbbrHiddenUntilFound AbbrHidden = "until-found"
	AbbrHiddenEmpty      AbbrHidden = ""
)

type AbbrInputmode string

const (
	AbbrInputmodeUrl     AbbrInputmode = "url"
	AbbrInputmodeDecimal AbbrInputmode = "decimal"
	AbbrInputmodeEmail   AbbrInputmode = "email"
	AbbrInputmodeNone    AbbrInputmode = "none"
	AbbrInputmodeNumeric AbbrInputmode = "numeric"
	AbbrInputmodeSearch  AbbrInputmode = "search"
	AbbrInputmodeTel     AbbrInputmode = "tel"
	AbbrInputmodeText    AbbrInputmode = "text"
)

type AbbrSpellcheck string

const (
	AbbrSpellcheckFalse AbbrSpellcheck = "false"
	AbbrSpellcheckTrue  AbbrSpellcheck = "true"
	AbbrSpellcheckEmpty AbbrSpellcheck = ""
)

type AbbrTranslate string

const (
	AbbrTranslateYes   AbbrTranslate = "yes"
	AbbrTranslateNo    AbbrTranslate = "no"
	AbbrTranslateEmpty AbbrTranslate = ""
)

type AbbrWritingsuggestions string

const (
	AbbrWritingsuggestionsFalse AbbrWritingsuggestions = "false"
	AbbrWritingsuggestionsTrue  AbbrWritingsuggestions = "true"
	AbbrWritingsuggestionsEmpty AbbrWritingsuggestions = ""
)

type abbrAttrs map[string]any

func (e *AbbrElement) AriaUnsafe(name string, s string) *AbbrElement {
	tag := strings.ToLower("aria-" + name)

	e.attributes[tag] = s

	return e
}

func (e *AbbrElement) Aria(name string, s string) *AbbrElement {
	return e.AriaUnsafe(name, html.EscapeString(s))
}

func (e *AbbrElement) Autocapitalize(a AbbrAutocapitalize) *AbbrElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *AbbrElement) Autocorrect(a AbbrAutocorrect) *AbbrElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *AbbrElement) Autofocus(b bool) *AbbrElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *AbbrElement) Class(s ...string) *AbbrElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *AbbrElement) Contenteditable(a AbbrContenteditable) *AbbrElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *AbbrElement) DataUnsafe(name string, s string) *AbbrElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *AbbrElement) Data(name string, s string) *AbbrElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *AbbrElement) Dir(a AbbrDir) *AbbrElement {
	e.attributes["dir"] = a

	return e
}

func (e *AbbrElement) Draggable(a AbbrDraggable) *AbbrElement {
	e.attributes["draggable"] = a

	return e
}

func (e *AbbrElement) Enterkeyhint(a AbbrEnterkeyhint) *AbbrElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *AbbrElement) Hidden(a AbbrHidden) *AbbrElement {
	e.attributes["hidden"] = a

	return e
}

func (e *AbbrElement) Id(s string) *AbbrElement {
	e.attributes["id"] = s

	return e
}

func (e *AbbrElement) Inert(b bool) *AbbrElement {
	e.attributes["inert"] = b

	return e
}

func (e *AbbrElement) Inputmode(a AbbrInputmode) *AbbrElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *AbbrElement) Itemid(s string) *AbbrElement {
	e.attributes["itemid"] = s

	return e
}

func (e *AbbrElement) Itemprop(s ...string) *AbbrElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *AbbrElement) Itemref(s ...string) *AbbrElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *AbbrElement) Itemscope(b bool) *AbbrElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *AbbrElement) Itemtype(s ...string) *AbbrElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *AbbrElement) Lang(s string) *AbbrElement {
	e.attributes["lang"] = s

	return e
}

func (e *AbbrElement) Nonce(s string) *AbbrElement {
	e.attributes["nonce"] = s

	return e
}

func (e *AbbrElement) Popover(s string) *AbbrElement {
	e.attributes["popover"] = s

	return e
}

func (e *AbbrElement) Role(s string) *AbbrElement {
	e.attributes["role"] = s

	return e
}

func (e *AbbrElement) Slot(s string) *AbbrElement {
	e.attributes["slot"] = s

	return e
}

func (e *AbbrElement) Spellcheck(a AbbrSpellcheck) *AbbrElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *AbbrElement) Style(s string) *AbbrElement {
	e.attributes["style"] = s

	return e
}

func (e *AbbrElement) Tabindex(i int) *AbbrElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *AbbrElement) Title(s string) *AbbrElement {
	e.attributes["title"] = s

	return e
}

func (e *AbbrElement) Translate(a AbbrTranslate) *AbbrElement {
	e.attributes["translate"] = a

	return e
}

func (e *AbbrElement) Writingsuggestions(a AbbrWritingsuggestions) *AbbrElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *AbbrElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	var sb strings.Builder
	sb.WriteString("<abbr")

	for key, v := range e.attributes {
		sb.WriteByte(' ')
		sb.WriteString(key)

		strVal := fmt.Sprintf("%v", v)
		if strVal != "" {
			sb.WriteByte('=')
			sb.WriteByte('"')
			sb.WriteString(strVal)
			sb.WriteByte('"')
		}
	}

	sb.WriteByte('>')
	for _, child := range e.children {
		if err := child.Render(&sb); err != nil {
			return err
		}
	}

	sb.WriteString("</abbr>")

	_, err := io.WriteString(w, sb.String())
	return err
}
