// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"strings"

	"github.com/derekmwright/htemel"
	"golang.org/x/net/html"
)

type DatalistElement struct {
	attributes datalistAttrs
	children   []htemel.Node
	skipRender bool
}

// Datalist creates a tag <datalist> instance and returns it for further modification.
// Any children passed will be nested within the tag.
//
// Spec Description: The datalist element represents a set of option elements that represent predefined options for other controls. In the rendering, the datalist element represents nothing and it, along with its children, should be hidden.
func Datalist(children ...htemel.Node) *DatalistElement {
	node := &DatalistElement{
		children:   children,
		attributes: make(datalistAttrs),
	}

	return node
}

func DatalistIf(condition bool, children ...htemel.Node) *DatalistElement {
	if condition {
		return Datalist(children...)
	}

	return &DatalistElement{
		skipRender: true,
	}
}

type DatalistAutocapitalizeAttrEnum string

const (
	DatalistAutocapitalizeAttrEnumCharacters DatalistAutocapitalizeAttrEnum = "characters"
	DatalistAutocapitalizeAttrEnumNone       DatalistAutocapitalizeAttrEnum = "none"
	DatalistAutocapitalizeAttrEnumOff        DatalistAutocapitalizeAttrEnum = "off"
	DatalistAutocapitalizeAttrEnumOn         DatalistAutocapitalizeAttrEnum = "on"
	DatalistAutocapitalizeAttrEnumSentences  DatalistAutocapitalizeAttrEnum = "sentences"
	DatalistAutocapitalizeAttrEnumWords      DatalistAutocapitalizeAttrEnum = "words"
)

type DatalistAutocorrectAttrEnum string

const (
	DatalistAutocorrectAttrEnumOff DatalistAutocorrectAttrEnum = "off"
	DatalistAutocorrectAttrEnumOn  DatalistAutocorrectAttrEnum = "on"
)

type DatalistContenteditableAttrEnum string

const (
	DatalistContenteditableAttrEnumTrue          DatalistContenteditableAttrEnum = "true"
	DatalistContenteditableAttrEnumFalse         DatalistContenteditableAttrEnum = "false"
	DatalistContenteditableAttrEnumPlaintextOnly DatalistContenteditableAttrEnum = "plaintext-only"
)

type datalistAttrs map[string]any

func (e *DatalistElement) Autocapitalize(a DatalistAutocapitalizeAttrEnum) *DatalistElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *DatalistElement) Autocorrect(a DatalistAutocorrectAttrEnum) *DatalistElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *DatalistElement) Autofocus(b bool) *DatalistElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *DatalistElement) Class(s ...string) *DatalistElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *DatalistElement) Contenteditable(a DatalistContenteditableAttrEnum) *DatalistElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *DatalistElement) Id(s string) *DatalistElement {
	e.attributes["id"] = s

	return e
}

func (e *DatalistElement) Slot(s string) *DatalistElement {
	e.attributes["slot"] = s

	return e
}

func (e *DatalistElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<datalist")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		w.Write([]byte(" " + key + "="))
		w.Write([]byte("\"" + html.EscapeString(fmt.Sprintf("%v", v)) + "\""))
		if i < c {
			w.Write([]byte(" "))
		}
		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}

	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</datalist>")); err != nil {
		return err
	}

	return nil
}
