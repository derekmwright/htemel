// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"slices"
	"strings"

	"github.com/derekmwright/htemel"
	"golang.org/x/net/html"
)

type DatalistElement struct {
	attributes datalistAttrs
	children   []htemel.Node
	skipRender bool
}

// Datalist creates a tag <datalist> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The datalist element represents a set of option elements that represent predefined options for other controls. In the rendering, the datalist element represents nothing and it, along with its children, should be hidden.
func Datalist(children ...htemel.Node) *DatalistElement {
	node := &DatalistElement{
		children:   children,
		attributes: make(datalistAttrs),
	}

	return node
}

func DatalistIf(condition bool, children ...htemel.Node) *DatalistElement {
	if condition {
		return Datalist(children...)
	}

	return &DatalistElement{
		children:   children,
		attributes: make(datalistAttrs),
		skipRender: true,
	}
}

func DatalistTernary(condition bool, true htemel.Node, false htemel.Node) *DatalistElement {
	if condition {
		return Datalist(true)
	}
	return Datalist(false)
}

// Children appends children to this element.
func (e *DatalistElement) Children(children ...htemel.Node) *DatalistElement {
	e.children = append(e.children, children...)
	return e
}

// With allows passing a function to modify the element via a closure.
func (e *DatalistElement) With(fn func(*DatalistElement)) *DatalistElement {
	fn(e)
	return e
}

// Textf adds a text node to the element with the given format string and arguments.
func (e *DatalistElement) Textf(format string, args ...any) *DatalistElement {
	return e.Children(htemel.Text(fmt.Sprintf(format, args...)))
}

// AddClass appends a class to the element.
func (e *DatalistElement) AddClass(classes ...string) *DatalistElement {
	current := e.attributes["class"].(string)
	all := append(strings.Fields(current), classes...)
	e.attributes["class"] = strings.Join(all, " ")
	return e
}

// ToggleClass toggles a class on or off.
func (e *DatalistElement) ToggleClass(class string, enable bool) *DatalistElement {
	classes := strings.Fields(e.attributes["class"].(string))
	idx := slices.Index(classes, class)
	if enable && idx == -1 {
		classes = append(classes, class)
	} else if !enable && idx >= 0 {
		classes = slices.Delete(classes, idx, idx+1)
	}
	e.attributes["class"] = strings.Join(classes, " ")
	return e
}

type DatalistAutocapitalize string

const (
	DatalistAutocapitalizeSentences  DatalistAutocapitalize = "sentences"
	DatalistAutocapitalizeWords      DatalistAutocapitalize = "words"
	DatalistAutocapitalizeCharacters DatalistAutocapitalize = "characters"
	DatalistAutocapitalizeNone       DatalistAutocapitalize = "none"
	DatalistAutocapitalizeOff        DatalistAutocapitalize = "off"
	DatalistAutocapitalizeOn         DatalistAutocapitalize = "on"
)

type DatalistAutocorrect string

const (
	DatalistAutocorrectOff   DatalistAutocorrect = "off"
	DatalistAutocorrectOn    DatalistAutocorrect = "on"
	DatalistAutocorrectEmpty DatalistAutocorrect = ""
)

type DatalistContenteditable string

const (
	DatalistContenteditableFalse         DatalistContenteditable = "false"
	DatalistContenteditablePlaintextOnly DatalistContenteditable = "plaintext-only"
	DatalistContenteditableTrue          DatalistContenteditable = "true"
	DatalistContenteditableEmpty         DatalistContenteditable = ""
)

type DatalistDir string

const (
	DatalistDirAuto DatalistDir = "auto"
	DatalistDirLtr  DatalistDir = "ltr"
	DatalistDirRtl  DatalistDir = "rtl"
)

type DatalistDraggable string

const (
	DatalistDraggableTrue  DatalistDraggable = "true"
	DatalistDraggableFalse DatalistDraggable = "false"
)

type DatalistEnterkeyhint string

const (
	DatalistEnterkeyhintGo       DatalistEnterkeyhint = "go"
	DatalistEnterkeyhintNext     DatalistEnterkeyhint = "next"
	DatalistEnterkeyhintPrevious DatalistEnterkeyhint = "previous"
	DatalistEnterkeyhintSearch   DatalistEnterkeyhint = "search"
	DatalistEnterkeyhintSend     DatalistEnterkeyhint = "send"
	DatalistEnterkeyhintDone     DatalistEnterkeyhint = "done"
	DatalistEnterkeyhintEnter    DatalistEnterkeyhint = "enter"
)

type DatalistHidden string

const (
	DatalistHiddenHidden     DatalistHidden = "hidden"
	DatalistHiddenUntilFound DatalistHidden = "until-found"
	DatalistHiddenEmpty      DatalistHidden = ""
)

type DatalistInputmode string

const (
	DatalistInputmodeNone    DatalistInputmode = "none"
	DatalistInputmodeNumeric DatalistInputmode = "numeric"
	DatalistInputmodeSearch  DatalistInputmode = "search"
	DatalistInputmodeTel     DatalistInputmode = "tel"
	DatalistInputmodeText    DatalistInputmode = "text"
	DatalistInputmodeUrl     DatalistInputmode = "url"
	DatalistInputmodeDecimal DatalistInputmode = "decimal"
	DatalistInputmodeEmail   DatalistInputmode = "email"
)

type DatalistSpellcheck string

const (
	DatalistSpellcheckFalse DatalistSpellcheck = "false"
	DatalistSpellcheckTrue  DatalistSpellcheck = "true"
	DatalistSpellcheckEmpty DatalistSpellcheck = ""
)

type DatalistTranslate string

const (
	DatalistTranslateNo    DatalistTranslate = "no"
	DatalistTranslateYes   DatalistTranslate = "yes"
	DatalistTranslateEmpty DatalistTranslate = ""
)

type DatalistWritingsuggestions string

const (
	DatalistWritingsuggestionsFalse DatalistWritingsuggestions = "false"
	DatalistWritingsuggestionsTrue  DatalistWritingsuggestions = "true"
	DatalistWritingsuggestionsEmpty DatalistWritingsuggestions = ""
)

type datalistAttrs map[string]any

func (e *DatalistElement) AriaUnsafe(name string, s string) *DatalistElement {
	tag := strings.ToLower("aria-" + name)

	e.attributes[tag] = s

	return e
}

func (e *DatalistElement) Aria(name string, s string) *DatalistElement {
	return e.AriaUnsafe(name, html.EscapeString(s))
}

func (e *DatalistElement) Autocapitalize(a DatalistAutocapitalize) *DatalistElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *DatalistElement) Autocorrect(a DatalistAutocorrect) *DatalistElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *DatalistElement) Autofocus(b bool) *DatalistElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *DatalistElement) Class(s ...string) *DatalistElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *DatalistElement) Contenteditable(a DatalistContenteditable) *DatalistElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *DatalistElement) DataUnsafe(name string, s string) *DatalistElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *DatalistElement) Data(name string, s string) *DatalistElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *DatalistElement) Dir(a DatalistDir) *DatalistElement {
	e.attributes["dir"] = a

	return e
}

func (e *DatalistElement) Draggable(a DatalistDraggable) *DatalistElement {
	e.attributes["draggable"] = a

	return e
}

func (e *DatalistElement) Enterkeyhint(a DatalistEnterkeyhint) *DatalistElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *DatalistElement) Hidden(a DatalistHidden) *DatalistElement {
	e.attributes["hidden"] = a

	return e
}

func (e *DatalistElement) Id(s string) *DatalistElement {
	e.attributes["id"] = s

	return e
}

func (e *DatalistElement) Inert(b bool) *DatalistElement {
	e.attributes["inert"] = b

	return e
}

func (e *DatalistElement) Inputmode(a DatalistInputmode) *DatalistElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *DatalistElement) Itemid(s string) *DatalistElement {
	e.attributes["itemid"] = s

	return e
}

func (e *DatalistElement) Itemprop(s ...string) *DatalistElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *DatalistElement) Itemref(s ...string) *DatalistElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *DatalistElement) Itemscope(b bool) *DatalistElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *DatalistElement) Itemtype(s ...string) *DatalistElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *DatalistElement) Lang(s string) *DatalistElement {
	e.attributes["lang"] = s

	return e
}

func (e *DatalistElement) Nonce(s string) *DatalistElement {
	e.attributes["nonce"] = s

	return e
}

func (e *DatalistElement) Popover(s string) *DatalistElement {
	e.attributes["popover"] = s

	return e
}

func (e *DatalistElement) Role(s string) *DatalistElement {
	e.attributes["role"] = s

	return e
}

func (e *DatalistElement) Slot(s string) *DatalistElement {
	e.attributes["slot"] = s

	return e
}

func (e *DatalistElement) Spellcheck(a DatalistSpellcheck) *DatalistElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *DatalistElement) Style(s string) *DatalistElement {
	e.attributes["style"] = s

	return e
}

func (e *DatalistElement) Tabindex(i int) *DatalistElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *DatalistElement) Title(s string) *DatalistElement {
	e.attributes["title"] = s

	return e
}

func (e *DatalistElement) Translate(a DatalistTranslate) *DatalistElement {
	e.attributes["translate"] = a

	return e
}

func (e *DatalistElement) Writingsuggestions(a DatalistWritingsuggestions) *DatalistElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *DatalistElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<datalist")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key))

		// Enum types support empty attributes and can be omitted.
		if fmt.Sprintf("%s", v) == "" {
			w.Write([]byte(" "))
			continue
		}

		w.Write([]byte("="))

		w.Write([]byte("\"" + fmt.Sprintf("%v", v) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}
	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</datalist>")); err != nil {
		return err
	}

	return nil
}
