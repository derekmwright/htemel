// Code generated by htemel. DO NOT EDIT.
package html

import (
  "fmt"
  "github.com/derekmwright/htemel"
  "golang.org/x/net/html"
  "io"
  "strings"
)

type AsideElement struct {
	attributes asideAttrs
	children []htemel.Node
	skipRender bool
}

// Aside creates a tag <aside> instance and returns it for further modification.
// Any children passed will be nested within the tag.
//
// Spec Description: The aside element represents a section of a page that consists of content that is tangentially related to the content around the aside element, and which could be considered separate from that content. Such sections are often represented as sidebars in printed typography.
func Aside(children ...htemel.Node) *AsideElement {
	node := &AsideElement{
		children: children,
		attributes: make(asideAttrs),
	}

	return node
}

func AsideIf(condition bool, children ...htemel.Node) *AsideElement {
	if condition {
		return Aside(children...)
	}

	return &AsideElement{
		skipRender: true,
	}
}

type AsideAutocapitalizeEnum string

const (
	AsideAutocapitalizeEnumNone AsideAutocapitalizeEnum = "none"
	AsideAutocapitalizeEnumOff AsideAutocapitalizeEnum = "off"
	AsideAutocapitalizeEnumOn AsideAutocapitalizeEnum = "on"
	AsideAutocapitalizeEnumSentences AsideAutocapitalizeEnum = "sentences"
	AsideAutocapitalizeEnumWords AsideAutocapitalizeEnum = "words"
	AsideAutocapitalizeEnumCharacters AsideAutocapitalizeEnum = "characters"
)

type AsideAutocorrectEnum string

const (
	AsideAutocorrectEnumOff AsideAutocorrectEnum = "off"
	AsideAutocorrectEnumOn AsideAutocorrectEnum = "on"
)

type AsideContenteditableEnum string

const (
	AsideContenteditableEnumFalse AsideContenteditableEnum = "false"
	AsideContenteditableEnumPlaintextOnly AsideContenteditableEnum = "plaintext-only"
	AsideContenteditableEnumTrue AsideContenteditableEnum = "true"
)

type AsideDirEnum string

const (
	AsideDirEnumAuto AsideDirEnum = "auto"
	AsideDirEnumLtr AsideDirEnum = "ltr"
	AsideDirEnumRtl AsideDirEnum = "rtl"
)

type AsideDraggableEnum string

const (
	AsideDraggableEnumTrue AsideDraggableEnum = "true"
	AsideDraggableEnumFalse AsideDraggableEnum = "false"
)

type AsideEnterkeyhintEnum string

const (
	AsideEnterkeyhintEnumGo AsideEnterkeyhintEnum = "go"
	AsideEnterkeyhintEnumNext AsideEnterkeyhintEnum = "next"
	AsideEnterkeyhintEnumPrevious AsideEnterkeyhintEnum = "previous"
	AsideEnterkeyhintEnumSearch AsideEnterkeyhintEnum = "search"
	AsideEnterkeyhintEnumSend AsideEnterkeyhintEnum = "send"
	AsideEnterkeyhintEnumDone AsideEnterkeyhintEnum = "done"
	AsideEnterkeyhintEnumEnter AsideEnterkeyhintEnum = "enter"
)

type AsideHiddenEnum string

const (
	AsideHiddenEnumHidden AsideHiddenEnum = "hidden"
	AsideHiddenEnumUntilFound AsideHiddenEnum = "until-found"
)

type asideAttrs map[string]any

func (e *AsideElement) Autocapitalize(a AsideAutocapitalizeEnum) *AsideElement {
	e.attributes["autocapitalize"] = a
	
	return e
}

func (e *AsideElement) Autocorrect(a AsideAutocorrectEnum) *AsideElement {
	e.attributes["autocorrect"] = a
	
	return e
}

func (e *AsideElement) Autofocus(b bool) *AsideElement {
	e.attributes["autofocus"] = b
	
	return e
}

func (e *AsideElement) Class(s ...string) *AsideElement {
	e.attributes["class"] = strings.Join(s, " ")
	
	return e
}

func (e *AsideElement) Contenteditable(a AsideContenteditableEnum) *AsideElement {
	e.attributes["contenteditable"] = a
	
	return e
}

func (e *AsideElement) Dir(a AsideDirEnum) *AsideElement {
	e.attributes["dir"] = a
	
	return e
}

func (e *AsideElement) Draggable(a AsideDraggableEnum) *AsideElement {
	e.attributes["draggable"] = a
	
	return e
}

func (e *AsideElement) Enterkeyhint(a AsideEnterkeyhintEnum) *AsideElement {
	e.attributes["enterkeyhint"] = a
	
	return e
}

func (e *AsideElement) Hidden(a AsideHiddenEnum) *AsideElement {
	e.attributes["hidden"] = a
	
	return e
}

func (e *AsideElement) Id(s string) *AsideElement {
	e.attributes["id"] = s
	
	return e
}

func (e *AsideElement) Slot(s string) *AsideElement {
	e.attributes["slot"] = s
	
	return e
}

func (e *AsideElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<aside")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key + "="))
		w.Write([]byte("\"" + html.EscapeString(fmt.Sprintf("%v", v)) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}

	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</aside>")); err != nil {
		return err
	}

	return nil
}
