// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"slices"
	"strings"

	"github.com/derekmwright/htemel"
	"golang.org/x/net/html"
)

type AsideElement struct {
	attributes asideAttrs
	children   []htemel.Node
	skipRender bool
}

// Aside creates a tag <aside> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The aside element represents a section of a page that consists of content that is tangentially related to the content around the aside element, and which could be considered separate from that content. Such sections are often represented as sidebars in printed typography.
func Aside(children ...htemel.Node) *AsideElement {
	node := &AsideElement{
		children:   children,
		attributes: make(asideAttrs),
	}

	return node
}

func AsideIf(condition bool, children ...htemel.Node) *AsideElement {
	if condition {
		return Aside(children...)
	}

	return &AsideElement{
		children:   children,
		attributes: make(asideAttrs),
		skipRender: true,
	}
}

func AsideTernary(condition bool, true htemel.Node, false htemel.Node) *AsideElement {
	if condition {
		return Aside(true)
	}
	return Aside(false)
}

// Children appends children to this element.
func (e *AsideElement) Children(children ...htemel.Node) *AsideElement {
	e.children = append(e.children, children...)
	return e
}

// With allows passing a function to modify the element via a closure.
func (e *AsideElement) With(fn func(*AsideElement)) *AsideElement {
	fn(e)
	return e
}

// Text adds a text node to the element.
func (e *AsideElement) Text(text string) *AsideElement {
	return e.Children(htemel.Text(text))
}

// Textf adds a text node to the element with the given format string and arguments.
func (e *AsideElement) Textf(format string, args ...any) *AsideElement {
	return e.Children(htemel.Text(fmt.Sprintf(format, args...)))
}

// AddClass appends a class to the element.
func (e *AsideElement) AddClass(classes ...string) *AsideElement {
	current := e.attributes["class"].(string)
	all := append(strings.Fields(current), classes...)
	e.attributes["class"] = strings.Join(all, " ")
	return e
}

// ToggleClass toggles a class on or off.
func (e *AsideElement) ToggleClass(class string, enable bool) *AsideElement {
	classes := strings.Fields(e.attributes["class"].(string))
	idx := slices.Index(classes, class)
	if enable && idx == -1 {
		classes = append(classes, class)
	} else if !enable && idx >= 0 {
		classes = slices.Delete(classes, idx, idx+1)
	}
	e.attributes["class"] = strings.Join(classes, " ")
	return e
}

type AsideAutocapitalize string

const (
	AsideAutocapitalizeOn         AsideAutocapitalize = "on"
	AsideAutocapitalizeSentences  AsideAutocapitalize = "sentences"
	AsideAutocapitalizeWords      AsideAutocapitalize = "words"
	AsideAutocapitalizeCharacters AsideAutocapitalize = "characters"
	AsideAutocapitalizeNone       AsideAutocapitalize = "none"
	AsideAutocapitalizeOff        AsideAutocapitalize = "off"
)

type AsideAutocorrect string

const (
	AsideAutocorrectOff   AsideAutocorrect = "off"
	AsideAutocorrectOn    AsideAutocorrect = "on"
	AsideAutocorrectEmpty AsideAutocorrect = ""
)

type AsideContenteditable string

const (
	AsideContenteditableFalse         AsideContenteditable = "false"
	AsideContenteditablePlaintextOnly AsideContenteditable = "plaintext-only"
	AsideContenteditableTrue          AsideContenteditable = "true"
	AsideContenteditableEmpty         AsideContenteditable = ""
)

type AsideDir string

const (
	AsideDirAuto AsideDir = "auto"
	AsideDirLtr  AsideDir = "ltr"
	AsideDirRtl  AsideDir = "rtl"
)

type AsideDraggable string

const (
	AsideDraggableFalse AsideDraggable = "false"
	AsideDraggableTrue  AsideDraggable = "true"
)

type AsideEnterkeyhint string

const (
	AsideEnterkeyhintSearch   AsideEnterkeyhint = "search"
	AsideEnterkeyhintSend     AsideEnterkeyhint = "send"
	AsideEnterkeyhintDone     AsideEnterkeyhint = "done"
	AsideEnterkeyhintEnter    AsideEnterkeyhint = "enter"
	AsideEnterkeyhintGo       AsideEnterkeyhint = "go"
	AsideEnterkeyhintNext     AsideEnterkeyhint = "next"
	AsideEnterkeyhintPrevious AsideEnterkeyhint = "previous"
)

type AsideHidden string

const (
	AsideHiddenHidden     AsideHidden = "hidden"
	AsideHiddenUntilFound AsideHidden = "until-found"
	AsideHiddenEmpty      AsideHidden = ""
)

type AsideInputmode string

const (
	AsideInputmodeNone    AsideInputmode = "none"
	AsideInputmodeNumeric AsideInputmode = "numeric"
	AsideInputmodeSearch  AsideInputmode = "search"
	AsideInputmodeTel     AsideInputmode = "tel"
	AsideInputmodeText    AsideInputmode = "text"
	AsideInputmodeUrl     AsideInputmode = "url"
	AsideInputmodeDecimal AsideInputmode = "decimal"
	AsideInputmodeEmail   AsideInputmode = "email"
)

type AsideSpellcheck string

const (
	AsideSpellcheckFalse AsideSpellcheck = "false"
	AsideSpellcheckTrue  AsideSpellcheck = "true"
	AsideSpellcheckEmpty AsideSpellcheck = ""
)

type AsideTranslate string

const (
	AsideTranslateNo    AsideTranslate = "no"
	AsideTranslateYes   AsideTranslate = "yes"
	AsideTranslateEmpty AsideTranslate = ""
)

type AsideWritingsuggestions string

const (
	AsideWritingsuggestionsFalse AsideWritingsuggestions = "false"
	AsideWritingsuggestionsTrue  AsideWritingsuggestions = "true"
	AsideWritingsuggestionsEmpty AsideWritingsuggestions = ""
)

type asideAttrs map[string]any

func (e *AsideElement) AriaUnsafe(name string, s string) *AsideElement {
	tag := strings.ToLower("aria-" + name)

	e.attributes[tag] = s

	return e
}

func (e *AsideElement) Aria(name string, s string) *AsideElement {
	return e.AriaUnsafe(name, html.EscapeString(s))
}

func (e *AsideElement) Autocapitalize(a AsideAutocapitalize) *AsideElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *AsideElement) Autocorrect(a AsideAutocorrect) *AsideElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *AsideElement) Autofocus(b bool) *AsideElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *AsideElement) Class(s ...string) *AsideElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *AsideElement) Contenteditable(a AsideContenteditable) *AsideElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *AsideElement) DataUnsafe(name string, s string) *AsideElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *AsideElement) Data(name string, s string) *AsideElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *AsideElement) Dir(a AsideDir) *AsideElement {
	e.attributes["dir"] = a

	return e
}

func (e *AsideElement) Draggable(a AsideDraggable) *AsideElement {
	e.attributes["draggable"] = a

	return e
}

func (e *AsideElement) Enterkeyhint(a AsideEnterkeyhint) *AsideElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *AsideElement) Hidden(a AsideHidden) *AsideElement {
	e.attributes["hidden"] = a

	return e
}

func (e *AsideElement) Id(s string) *AsideElement {
	e.attributes["id"] = s

	return e
}

func (e *AsideElement) Inert(b bool) *AsideElement {
	e.attributes["inert"] = b

	return e
}

func (e *AsideElement) Inputmode(a AsideInputmode) *AsideElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *AsideElement) Itemid(s string) *AsideElement {
	e.attributes["itemid"] = s

	return e
}

func (e *AsideElement) Itemprop(s ...string) *AsideElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *AsideElement) Itemref(s ...string) *AsideElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *AsideElement) Itemscope(b bool) *AsideElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *AsideElement) Itemtype(s ...string) *AsideElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *AsideElement) Lang(s string) *AsideElement {
	e.attributes["lang"] = s

	return e
}

func (e *AsideElement) Nonce(s string) *AsideElement {
	e.attributes["nonce"] = s

	return e
}

func (e *AsideElement) Popover(s string) *AsideElement {
	e.attributes["popover"] = s

	return e
}

func (e *AsideElement) Role(s string) *AsideElement {
	e.attributes["role"] = s

	return e
}

func (e *AsideElement) Slot(s string) *AsideElement {
	e.attributes["slot"] = s

	return e
}

func (e *AsideElement) Spellcheck(a AsideSpellcheck) *AsideElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *AsideElement) Style(s string) *AsideElement {
	e.attributes["style"] = s

	return e
}

func (e *AsideElement) Tabindex(i int) *AsideElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *AsideElement) Title(s string) *AsideElement {
	e.attributes["title"] = s

	return e
}

func (e *AsideElement) Translate(a AsideTranslate) *AsideElement {
	e.attributes["translate"] = a

	return e
}

func (e *AsideElement) Writingsuggestions(a AsideWritingsuggestions) *AsideElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *AsideElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	var sb strings.Builder
	sb.WriteString("<aside")

	for key, v := range e.attributes {
		sb.WriteByte(' ')
		sb.WriteString(key)

		strVal := fmt.Sprintf("%v", v)
		if strVal != "" {
			sb.WriteByte('=')
			sb.WriteByte('"')
			sb.WriteString(strVal)
			sb.WriteByte('"')
		}
	}

	sb.WriteByte('>')
	for _, child := range e.children {
		if err := child.Render(&sb); err != nil {
			return err
		}
	}

	sb.WriteString("</aside>")

	_, err := io.WriteString(w, sb.String())
	return err
}
