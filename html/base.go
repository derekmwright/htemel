// Code generated by htemel. DO NOT EDIT.
package html

import (
  "fmt"
  "github.com/derekmwright/htemel"
  "golang.org/x/net/html"
  "io"
  "strings"
)

type BaseElement struct {
	attributes baseAttrs
	children []htemel.Node
	skipRender bool
}

// Base creates a tag <base> instance and returns it for further modification.
// Any children passed will be nested within the tag.
//
// Spec Description: The base element allows authors to specify the document base URL for the purposes of parsing URLs, and the name of the default navigable for the purposes of following hyperlinks. The element does not represent any content beyond this information.
func Base(children ...htemel.Node) *BaseElement {
	node := &BaseElement{
		children: children,
		attributes: make(baseAttrs),
	}

	return node
}

func BaseIf(condition bool, children ...htemel.Node) *BaseElement {
	if condition {
		return Base(children...)
	}

	return &BaseElement{
		skipRender: true,
	}
}

type BaseAutocapitalizeEnum string

const (
	BaseAutocapitalizeEnumSentences BaseAutocapitalizeEnum = "sentences"
	BaseAutocapitalizeEnumWords BaseAutocapitalizeEnum = "words"
	BaseAutocapitalizeEnumCharacters BaseAutocapitalizeEnum = "characters"
	BaseAutocapitalizeEnumNone BaseAutocapitalizeEnum = "none"
	BaseAutocapitalizeEnumOff BaseAutocapitalizeEnum = "off"
	BaseAutocapitalizeEnumOn BaseAutocapitalizeEnum = "on"
)

type BaseAutocorrectEnum string

const (
	BaseAutocorrectEnumOff BaseAutocorrectEnum = "off"
	BaseAutocorrectEnumOn BaseAutocorrectEnum = "on"
)

type BaseContenteditableEnum string

const (
	BaseContenteditableEnumFalse BaseContenteditableEnum = "false"
	BaseContenteditableEnumPlaintextOnly BaseContenteditableEnum = "plaintext-only"
	BaseContenteditableEnumTrue BaseContenteditableEnum = "true"
)

type BaseDirEnum string

const (
	BaseDirEnumRtl BaseDirEnum = "rtl"
	BaseDirEnumAuto BaseDirEnum = "auto"
	BaseDirEnumLtr BaseDirEnum = "ltr"
)

type BaseDraggableEnum string

const (
	BaseDraggableEnumFalse BaseDraggableEnum = "false"
	BaseDraggableEnumTrue BaseDraggableEnum = "true"
)

type BaseEnterkeyhintEnum string

const (
	BaseEnterkeyhintEnumDone BaseEnterkeyhintEnum = "done"
	BaseEnterkeyhintEnumEnter BaseEnterkeyhintEnum = "enter"
	BaseEnterkeyhintEnumGo BaseEnterkeyhintEnum = "go"
	BaseEnterkeyhintEnumNext BaseEnterkeyhintEnum = "next"
	BaseEnterkeyhintEnumPrevious BaseEnterkeyhintEnum = "previous"
	BaseEnterkeyhintEnumSearch BaseEnterkeyhintEnum = "search"
	BaseEnterkeyhintEnumSend BaseEnterkeyhintEnum = "send"
)

type BaseHiddenEnum string

const (
	BaseHiddenEnumHidden BaseHiddenEnum = "hidden"
	BaseHiddenEnumUntilFound BaseHiddenEnum = "until-found"
)

type baseAttrs map[string]any

func (e *BaseElement) Autocapitalize(a BaseAutocapitalizeEnum) *BaseElement {
	e.attributes["autocapitalize"] = a
	
	return e
}

func (e *BaseElement) Autocorrect(a BaseAutocorrectEnum) *BaseElement {
	e.attributes["autocorrect"] = a
	
	return e
}

func (e *BaseElement) Autofocus(b bool) *BaseElement {
	e.attributes["autofocus"] = b
	
	return e
}

func (e *BaseElement) Class(s ...string) *BaseElement {
	e.attributes["class"] = strings.Join(s, " ")
	
	return e
}

func (e *BaseElement) Contenteditable(a BaseContenteditableEnum) *BaseElement {
	e.attributes["contenteditable"] = a
	
	return e
}

func (e *BaseElement) Dir(a BaseDirEnum) *BaseElement {
	e.attributes["dir"] = a
	
	return e
}

func (e *BaseElement) Draggable(a BaseDraggableEnum) *BaseElement {
	e.attributes["draggable"] = a
	
	return e
}

func (e *BaseElement) Enterkeyhint(a BaseEnterkeyhintEnum) *BaseElement {
	e.attributes["enterkeyhint"] = a
	
	return e
}

func (e *BaseElement) Hidden(a BaseHiddenEnum) *BaseElement {
	e.attributes["hidden"] = a
	
	return e
}

func (e *BaseElement) Id(s string) *BaseElement {
	e.attributes["id"] = s
	
	return e
}

func (e *BaseElement) Slot(s string) *BaseElement {
	e.attributes["slot"] = s
	
	return e
}

func (e *BaseElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<base")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key + "="))
		w.Write([]byte("\"" + html.EscapeString(fmt.Sprintf("%v", v)) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}

	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</base>")); err != nil {
		return err
	}

	return nil
}
