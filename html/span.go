// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"strings"

	"github.com/derekmwright/htemel"
	"golang.org/x/net/html"
)

type SpanElement struct {
	attributes spanAttrs
	children   []htemel.Node
	skipRender bool
}

// Span creates a tag <span> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The span element doesn't mean anything on its own, but can be useful when used together with the global attributes, e.g. class, lang, or dir. It represents its children.
func Span(children ...htemel.Node) *SpanElement {
	node := &SpanElement{
		children:   children,
		attributes: make(spanAttrs),
	}

	return node
}

func SpanIf(condition bool, children ...htemel.Node) *SpanElement {
	if condition {
		return Span(children...)
	}

	return &SpanElement{
		children:   children,
		attributes: make(spanAttrs),
		skipRender: true,
	}
}

func SpanTernary(condition bool, true htemel.Node, false htemel.Node) *SpanElement {
	if condition {
		return Span(true)
	}

	return Span(false)
}

// Children appends children to this element.
func (e *SpanElement) Children(children ...htemel.Node) *SpanElement {
	e.children = append(e.children, children...)

	return e
}

type SpanAutocapitalize string

const (
	SpanAutocapitalizeOn         SpanAutocapitalize = "on"
	SpanAutocapitalizeSentences  SpanAutocapitalize = "sentences"
	SpanAutocapitalizeWords      SpanAutocapitalize = "words"
	SpanAutocapitalizeCharacters SpanAutocapitalize = "characters"
	SpanAutocapitalizeNone       SpanAutocapitalize = "none"
	SpanAutocapitalizeOff        SpanAutocapitalize = "off"
)

type SpanAutocorrect string

const (
	SpanAutocorrectOff   SpanAutocorrect = "off"
	SpanAutocorrectOn    SpanAutocorrect = "on"
	SpanAutocorrectEmpty SpanAutocorrect = ""
)

type SpanContenteditable string

const (
	SpanContenteditableFalse         SpanContenteditable = "false"
	SpanContenteditablePlaintextOnly SpanContenteditable = "plaintext-only"
	SpanContenteditableTrue          SpanContenteditable = "true"
	SpanContenteditableEmpty         SpanContenteditable = ""
)

type SpanDir string

const (
	SpanDirRtl  SpanDir = "rtl"
	SpanDirAuto SpanDir = "auto"
	SpanDirLtr  SpanDir = "ltr"
)

type SpanDraggable string

const (
	SpanDraggableTrue  SpanDraggable = "true"
	SpanDraggableFalse SpanDraggable = "false"
)

type SpanEnterkeyhint string

const (
	SpanEnterkeyhintDone     SpanEnterkeyhint = "done"
	SpanEnterkeyhintEnter    SpanEnterkeyhint = "enter"
	SpanEnterkeyhintGo       SpanEnterkeyhint = "go"
	SpanEnterkeyhintNext     SpanEnterkeyhint = "next"
	SpanEnterkeyhintPrevious SpanEnterkeyhint = "previous"
	SpanEnterkeyhintSearch   SpanEnterkeyhint = "search"
	SpanEnterkeyhintSend     SpanEnterkeyhint = "send"
)

type SpanHidden string

const (
	SpanHiddenHidden     SpanHidden = "hidden"
	SpanHiddenUntilFound SpanHidden = "until-found"
	SpanHiddenEmpty      SpanHidden = ""
)

type SpanInputmode string

const (
	SpanInputmodeTel     SpanInputmode = "tel"
	SpanInputmodeText    SpanInputmode = "text"
	SpanInputmodeUrl     SpanInputmode = "url"
	SpanInputmodeDecimal SpanInputmode = "decimal"
	SpanInputmodeEmail   SpanInputmode = "email"
	SpanInputmodeNone    SpanInputmode = "none"
	SpanInputmodeNumeric SpanInputmode = "numeric"
	SpanInputmodeSearch  SpanInputmode = "search"
)

type SpanSpellcheck string

const (
	SpanSpellcheckFalse SpanSpellcheck = "false"
	SpanSpellcheckTrue  SpanSpellcheck = "true"
	SpanSpellcheckEmpty SpanSpellcheck = ""
)

type SpanTranslate string

const (
	SpanTranslateNo    SpanTranslate = "no"
	SpanTranslateYes   SpanTranslate = "yes"
	SpanTranslateEmpty SpanTranslate = ""
)

type SpanWritingsuggestions string

const (
	SpanWritingsuggestionsFalse SpanWritingsuggestions = "false"
	SpanWritingsuggestionsTrue  SpanWritingsuggestions = "true"
	SpanWritingsuggestionsEmpty SpanWritingsuggestions = ""
)

type spanAttrs map[string]any

func (e *SpanElement) AriaUnsafe(name string, s string) *SpanElement {
	tag := strings.ToLower("aria-" + name)

	e.attributes[tag] = s

	return e
}

func (e *SpanElement) Aria(name string, s string) *SpanElement {
	return e.AriaUnsafe(name, html.EscapeString(s))
}

func (e *SpanElement) Autocapitalize(a SpanAutocapitalize) *SpanElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *SpanElement) Autocorrect(a SpanAutocorrect) *SpanElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *SpanElement) Autofocus(b bool) *SpanElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *SpanElement) Class(s ...string) *SpanElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *SpanElement) Contenteditable(a SpanContenteditable) *SpanElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *SpanElement) DataUnsafe(name string, s string) *SpanElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *SpanElement) Data(name string, s string) *SpanElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *SpanElement) Dir(a SpanDir) *SpanElement {
	e.attributes["dir"] = a

	return e
}

func (e *SpanElement) Draggable(a SpanDraggable) *SpanElement {
	e.attributes["draggable"] = a

	return e
}

func (e *SpanElement) Enterkeyhint(a SpanEnterkeyhint) *SpanElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *SpanElement) Hidden(a SpanHidden) *SpanElement {
	e.attributes["hidden"] = a

	return e
}

func (e *SpanElement) Id(s string) *SpanElement {
	e.attributes["id"] = s

	return e
}

func (e *SpanElement) Inert(b bool) *SpanElement {
	e.attributes["inert"] = b

	return e
}

func (e *SpanElement) Inputmode(a SpanInputmode) *SpanElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *SpanElement) Itemid(s string) *SpanElement {
	e.attributes["itemid"] = s

	return e
}

func (e *SpanElement) Itemprop(s ...string) *SpanElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *SpanElement) Itemref(s ...string) *SpanElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *SpanElement) Itemscope(b bool) *SpanElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *SpanElement) Itemtype(s ...string) *SpanElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *SpanElement) Lang(s string) *SpanElement {
	e.attributes["lang"] = s

	return e
}

func (e *SpanElement) Nonce(s string) *SpanElement {
	e.attributes["nonce"] = s

	return e
}

func (e *SpanElement) Popover(s string) *SpanElement {
	e.attributes["popover"] = s

	return e
}

func (e *SpanElement) Role(s string) *SpanElement {
	e.attributes["role"] = s

	return e
}

func (e *SpanElement) Slot(s string) *SpanElement {
	e.attributes["slot"] = s

	return e
}

func (e *SpanElement) Spellcheck(a SpanSpellcheck) *SpanElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *SpanElement) Style(s string) *SpanElement {
	e.attributes["style"] = s

	return e
}

func (e *SpanElement) Tabindex(i int) *SpanElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *SpanElement) Title(s string) *SpanElement {
	e.attributes["title"] = s

	return e
}

func (e *SpanElement) Translate(a SpanTranslate) *SpanElement {
	e.attributes["translate"] = a

	return e
}

func (e *SpanElement) Writingsuggestions(a SpanWritingsuggestions) *SpanElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *SpanElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<span")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key))

		// Enum types support empty attributes and can be omitted.
		if fmt.Sprintf("%s", v) == "" {
			w.Write([]byte(" "))
			continue
		}

		w.Write([]byte("="))

		w.Write([]byte("\"" + fmt.Sprintf("%v", v) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}
	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</span>")); err != nil {
		return err
	}

	return nil
}
