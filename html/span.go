// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"slices"
	"strings"

	"github.com/go-htemel/htemel"
	"golang.org/x/net/html"
)

type SpanElement struct {
	attributes spanAttrs
	children   []htemel.Node
	skipRender bool
}

// Span creates a tag <span> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The span element doesn't mean anything on its own, but can be useful when used together with the global attributes, e.g. class, lang, or dir. It represents its children.
func Span(children ...htemel.Node) *SpanElement {
	node := &SpanElement{
		children:   children,
		attributes: make(spanAttrs),
	}

	return node
}

func SpanIf(condition bool, children ...htemel.Node) *SpanElement {
	if condition {
		return Span(children...)
	}

	return &SpanElement{
		children:   children,
		attributes: make(spanAttrs),
		skipRender: true,
	}
}

func SpanTernary(condition bool, true htemel.Node, false htemel.Node) *SpanElement {
	if condition {
		return Span(true)
	}
	return Span(false)
}

// Children appends children to this element.
func (e *SpanElement) Children(children ...htemel.Node) *SpanElement {
	e.children = append(e.children, children...)
	return e
}

// With allows passing a function to modify the element via a closure.
func (e *SpanElement) With(fn func(*SpanElement)) *SpanElement {
	fn(e)
	return e
}

// Text adds a text node to the element.
func (e *SpanElement) Text(text string) *SpanElement {
	return e.Children(htemel.Text(text))
}

// Textf adds a text node to the element with the given format string and arguments.
func (e *SpanElement) Textf(format string, args ...any) *SpanElement {
	return e.Children(htemel.Text(fmt.Sprintf(format, args...)))
}

// If conditionally adds a child node to the element if the condition is true, otherwise it is a no-op.
func (e *SpanElement) If(cond bool, child htemel.Node) *SpanElement {
	if cond {
		return e.Children(child)
	}
	return e
}

func (e *SpanElement) IfElse(cond bool, then, els htemel.Node) *SpanElement {
	if cond {
		e.Children(then)
	} else {
		e.Children(els)
	}
	return e
}

// IfThen conditionally calls the given function with the element if the condition is true, otherwise it is a no-op.
func (e *SpanElement) IfThen(cond bool, fn func(*SpanElement)) *SpanElement {
	if cond {
		fn(e)
	}
	return e
}

// AddClass appends a class to the element.
func (e *SpanElement) AddClass(classes ...string) *SpanElement {
	current := e.attributes["class"].(string)
	all := append(strings.Fields(current), classes...)
	e.attributes["class"] = strings.Join(all, " ")
	return e
}

// ToggleClass toggles a class on or off.
func (e *SpanElement) ToggleClass(class string, enable bool) *SpanElement {
	classes := strings.Fields(e.attributes["class"].(string))
	idx := slices.Index(classes, class)
	if enable && idx == -1 {
		classes = append(classes, class)
	} else if !enable && idx >= 0 {
		classes = slices.Delete(classes, idx, idx+1)
	}
	e.attributes["class"] = strings.Join(classes, " ")
	return e
}

type SpanAutocapitalize string

const (
	SpanAutocapitalizeCharacters SpanAutocapitalize = "characters"
	SpanAutocapitalizeNone       SpanAutocapitalize = "none"
	SpanAutocapitalizeOff        SpanAutocapitalize = "off"
	SpanAutocapitalizeOn         SpanAutocapitalize = "on"
	SpanAutocapitalizeSentences  SpanAutocapitalize = "sentences"
	SpanAutocapitalizeWords      SpanAutocapitalize = "words"
)

type SpanAutocorrect string

const (
	SpanAutocorrectOff   SpanAutocorrect = "off"
	SpanAutocorrectOn    SpanAutocorrect = "on"
	SpanAutocorrectEmpty SpanAutocorrect = ""
)

type SpanContenteditable string

const (
	SpanContenteditableFalse         SpanContenteditable = "false"
	SpanContenteditablePlaintextOnly SpanContenteditable = "plaintext-only"
	SpanContenteditableTrue          SpanContenteditable = "true"
	SpanContenteditableEmpty         SpanContenteditable = ""
)

type SpanDir string

const (
	SpanDirAuto SpanDir = "auto"
	SpanDirLtr  SpanDir = "ltr"
	SpanDirRtl  SpanDir = "rtl"
)

type SpanDraggable string

const (
	SpanDraggableFalse SpanDraggable = "false"
	SpanDraggableTrue  SpanDraggable = "true"
)

type SpanEnterkeyhint string

const (
	SpanEnterkeyhintNext     SpanEnterkeyhint = "next"
	SpanEnterkeyhintPrevious SpanEnterkeyhint = "previous"
	SpanEnterkeyhintSearch   SpanEnterkeyhint = "search"
	SpanEnterkeyhintSend     SpanEnterkeyhint = "send"
	SpanEnterkeyhintDone     SpanEnterkeyhint = "done"
	SpanEnterkeyhintEnter    SpanEnterkeyhint = "enter"
	SpanEnterkeyhintGo       SpanEnterkeyhint = "go"
)

type SpanHidden string

const (
	SpanHiddenHidden     SpanHidden = "hidden"
	SpanHiddenUntilFound SpanHidden = "until-found"
	SpanHiddenEmpty      SpanHidden = ""
)

type SpanInputmode string

const (
	SpanInputmodeUrl     SpanInputmode = "url"
	SpanInputmodeDecimal SpanInputmode = "decimal"
	SpanInputmodeEmail   SpanInputmode = "email"
	SpanInputmodeNone    SpanInputmode = "none"
	SpanInputmodeNumeric SpanInputmode = "numeric"
	SpanInputmodeSearch  SpanInputmode = "search"
	SpanInputmodeTel     SpanInputmode = "tel"
	SpanInputmodeText    SpanInputmode = "text"
)

type SpanSpellcheck string

const (
	SpanSpellcheckFalse SpanSpellcheck = "false"
	SpanSpellcheckTrue  SpanSpellcheck = "true"
	SpanSpellcheckEmpty SpanSpellcheck = ""
)

type SpanTranslate string

const (
	SpanTranslateNo    SpanTranslate = "no"
	SpanTranslateYes   SpanTranslate = "yes"
	SpanTranslateEmpty SpanTranslate = ""
)

type SpanWritingsuggestions string

const (
	SpanWritingsuggestionsFalse SpanWritingsuggestions = "false"
	SpanWritingsuggestionsTrue  SpanWritingsuggestions = "true"
	SpanWritingsuggestionsEmpty SpanWritingsuggestions = ""
)

type spanAttrs map[string]any

func (e *SpanElement) AriaUnsafe(name string, s string) *SpanElement {
	tag := strings.ToLower("aria-" + name)

	e.attributes[tag] = s

	return e
}

func (e *SpanElement) Aria(name string, s string) *SpanElement {
	return e.AriaUnsafe(name, html.EscapeString(s))
}

func (e *SpanElement) Autocapitalize(a SpanAutocapitalize) *SpanElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *SpanElement) Autocorrect(a SpanAutocorrect) *SpanElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *SpanElement) Autofocus(b bool) *SpanElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *SpanElement) Class(s ...string) *SpanElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *SpanElement) Contenteditable(a SpanContenteditable) *SpanElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *SpanElement) DataUnsafe(name string, s string) *SpanElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *SpanElement) Data(name string, s string) *SpanElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *SpanElement) Dir(a SpanDir) *SpanElement {
	e.attributes["dir"] = a

	return e
}

func (e *SpanElement) Draggable(a SpanDraggable) *SpanElement {
	e.attributes["draggable"] = a

	return e
}

func (e *SpanElement) Enterkeyhint(a SpanEnterkeyhint) *SpanElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *SpanElement) Hidden(a SpanHidden) *SpanElement {
	e.attributes["hidden"] = a

	return e
}

func (e *SpanElement) Id(s string) *SpanElement {
	e.attributes["id"] = s

	return e
}

func (e *SpanElement) Inert(b bool) *SpanElement {
	e.attributes["inert"] = b

	return e
}

func (e *SpanElement) Inputmode(a SpanInputmode) *SpanElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *SpanElement) Itemid(s string) *SpanElement {
	e.attributes["itemid"] = s

	return e
}

func (e *SpanElement) Itemprop(s ...string) *SpanElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *SpanElement) Itemref(s ...string) *SpanElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *SpanElement) Itemscope(b bool) *SpanElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *SpanElement) Itemtype(s ...string) *SpanElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *SpanElement) Lang(s string) *SpanElement {
	e.attributes["lang"] = s

	return e
}

func (e *SpanElement) Nonce(s string) *SpanElement {
	e.attributes["nonce"] = s

	return e
}

func (e *SpanElement) Popover(s string) *SpanElement {
	e.attributes["popover"] = s

	return e
}

func (e *SpanElement) Role(s string) *SpanElement {
	e.attributes["role"] = s

	return e
}

func (e *SpanElement) Slot(s string) *SpanElement {
	e.attributes["slot"] = s

	return e
}

func (e *SpanElement) Spellcheck(a SpanSpellcheck) *SpanElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *SpanElement) Style(s string) *SpanElement {
	e.attributes["style"] = s

	return e
}

func (e *SpanElement) Tabindex(i int) *SpanElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *SpanElement) Title(s string) *SpanElement {
	e.attributes["title"] = s

	return e
}

func (e *SpanElement) Translate(a SpanTranslate) *SpanElement {
	e.attributes["translate"] = a

	return e
}

func (e *SpanElement) Writingsuggestions(a SpanWritingsuggestions) *SpanElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *SpanElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	var sb strings.Builder
	sb.WriteString("<span")

	for key, v := range e.attributes {
		sb.WriteByte(' ')
		sb.WriteString(key)

		strVal := fmt.Sprintf("%v", v)
		if strVal != "" {
			sb.WriteByte('=')
			sb.WriteByte('"')
			sb.WriteString(strVal)
			sb.WriteByte('"')
		}
	}

	sb.WriteByte('>')
	for _, child := range e.children {
		if err := child.Render(&sb); err != nil {
			return err
		}
	}

	sb.WriteString("</span>")

	_, err := io.WriteString(w, sb.String())
	return err
}
