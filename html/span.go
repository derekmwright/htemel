// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"strings"

	"github.com/derekmwright/htemel"
	"golang.org/x/net/html"
)

type SpanElement struct {
	attributes spanAttrs
	children   []htemel.Node
	skipRender bool
	indent     int
}

// Span creates a tag <span> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The span element doesn't mean anything on its own, but can be useful when used together with the global attributes, e.g. class, lang, or dir. It represents its children.
func Span(children ...htemel.Node) *SpanElement {
	node := &SpanElement{
		children:   children,
		attributes: make(spanAttrs),
	}

	return node
}

func SpanIf(condition bool, children ...htemel.Node) *SpanElement {
	if condition {
		return Span(children...)
	}

	return &SpanElement{
		children:   children,
		attributes: make(spanAttrs),
		skipRender: true,
	}
}

func SpanTernary(condition bool, true htemel.Node, false htemel.Node) *SpanElement {
	if condition {
		return Span(true)
	}

	return Span(false)
}

type SpanAutocapitalizeEnum string

const (
	SpanAutocapitalizeEnumSentences  SpanAutocapitalizeEnum = "sentences"
	SpanAutocapitalizeEnumWords      SpanAutocapitalizeEnum = "words"
	SpanAutocapitalizeEnumCharacters SpanAutocapitalizeEnum = "characters"
	SpanAutocapitalizeEnumNone       SpanAutocapitalizeEnum = "none"
	SpanAutocapitalizeEnumOff        SpanAutocapitalizeEnum = "off"
	SpanAutocapitalizeEnumOn         SpanAutocapitalizeEnum = "on"
)

type SpanAutocorrectEnum string

const (
	SpanAutocorrectEnumOff   SpanAutocorrectEnum = "off"
	SpanAutocorrectEnumOn    SpanAutocorrectEnum = "on"
	SpanAutocorrectEnumEmpty SpanAutocorrectEnum = ""
)

type SpanContenteditableEnum string

const (
	SpanContenteditableEnumFalse         SpanContenteditableEnum = "false"
	SpanContenteditableEnumPlaintextOnly SpanContenteditableEnum = "plaintext-only"
	SpanContenteditableEnumTrue          SpanContenteditableEnum = "true"
	SpanContenteditableEnumEmpty         SpanContenteditableEnum = ""
)

type SpanDirEnum string

const (
	SpanDirEnumAuto SpanDirEnum = "auto"
	SpanDirEnumLtr  SpanDirEnum = "ltr"
	SpanDirEnumRtl  SpanDirEnum = "rtl"
)

type SpanDraggableEnum string

const (
	SpanDraggableEnumFalse SpanDraggableEnum = "false"
	SpanDraggableEnumTrue  SpanDraggableEnum = "true"
)

type SpanEnterkeyhintEnum string

const (
	SpanEnterkeyhintEnumPrevious SpanEnterkeyhintEnum = "previous"
	SpanEnterkeyhintEnumSearch   SpanEnterkeyhintEnum = "search"
	SpanEnterkeyhintEnumSend     SpanEnterkeyhintEnum = "send"
	SpanEnterkeyhintEnumDone     SpanEnterkeyhintEnum = "done"
	SpanEnterkeyhintEnumEnter    SpanEnterkeyhintEnum = "enter"
	SpanEnterkeyhintEnumGo       SpanEnterkeyhintEnum = "go"
	SpanEnterkeyhintEnumNext     SpanEnterkeyhintEnum = "next"
)

type SpanHiddenEnum string

const (
	SpanHiddenEnumHidden     SpanHiddenEnum = "hidden"
	SpanHiddenEnumUntilFound SpanHiddenEnum = "until-found"
	SpanHiddenEnumEmpty      SpanHiddenEnum = ""
)

type SpanInputmodeEnum string

const (
	SpanInputmodeEnumDecimal SpanInputmodeEnum = "decimal"
	SpanInputmodeEnumEmail   SpanInputmodeEnum = "email"
	SpanInputmodeEnumNone    SpanInputmodeEnum = "none"
	SpanInputmodeEnumNumeric SpanInputmodeEnum = "numeric"
	SpanInputmodeEnumSearch  SpanInputmodeEnum = "search"
	SpanInputmodeEnumTel     SpanInputmodeEnum = "tel"
	SpanInputmodeEnumText    SpanInputmodeEnum = "text"
	SpanInputmodeEnumUrl     SpanInputmodeEnum = "url"
)

type SpanSpellcheckEnum string

const (
	SpanSpellcheckEnumFalse SpanSpellcheckEnum = "false"
	SpanSpellcheckEnumTrue  SpanSpellcheckEnum = "true"
	SpanSpellcheckEnumEmpty SpanSpellcheckEnum = ""
)

type SpanTranslateEnum string

const (
	SpanTranslateEnumYes   SpanTranslateEnum = "yes"
	SpanTranslateEnumNo    SpanTranslateEnum = "no"
	SpanTranslateEnumEmpty SpanTranslateEnum = ""
)

type SpanWritingsuggestionsEnum string

const (
	SpanWritingsuggestionsEnumFalse SpanWritingsuggestionsEnum = "false"
	SpanWritingsuggestionsEnumTrue  SpanWritingsuggestionsEnum = "true"
	SpanWritingsuggestionsEnumEmpty SpanWritingsuggestionsEnum = ""
)

type spanAttrs map[string]any

func (e *SpanElement) Autocapitalize(a SpanAutocapitalizeEnum) *SpanElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *SpanElement) Autocorrect(a SpanAutocorrectEnum) *SpanElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *SpanElement) Autofocus(b bool) *SpanElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *SpanElement) Class(s ...string) *SpanElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *SpanElement) Contenteditable(a SpanContenteditableEnum) *SpanElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *SpanElement) DataUnsafe(name string, s string) *SpanElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *SpanElement) Data(name string, s string) *SpanElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *SpanElement) Dir(a SpanDirEnum) *SpanElement {
	e.attributes["dir"] = a

	return e
}

func (e *SpanElement) Draggable(a SpanDraggableEnum) *SpanElement {
	e.attributes["draggable"] = a

	return e
}

func (e *SpanElement) Enterkeyhint(a SpanEnterkeyhintEnum) *SpanElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *SpanElement) Hidden(a SpanHiddenEnum) *SpanElement {
	e.attributes["hidden"] = a

	return e
}

func (e *SpanElement) Id(s string) *SpanElement {
	e.attributes["id"] = s

	return e
}

func (e *SpanElement) Inert(b bool) *SpanElement {
	e.attributes["inert"] = b

	return e
}

func (e *SpanElement) Inputmode(a SpanInputmodeEnum) *SpanElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *SpanElement) Itemid(s string) *SpanElement {
	e.attributes["itemid"] = s

	return e
}

func (e *SpanElement) Itemprop(s ...string) *SpanElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *SpanElement) Itemref(s ...string) *SpanElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *SpanElement) Itemscope(b bool) *SpanElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *SpanElement) Itemtype(s ...string) *SpanElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *SpanElement) Lang(s string) *SpanElement {
	e.attributes["lang"] = s

	return e
}

func (e *SpanElement) Nonce(s string) *SpanElement {
	e.attributes["nonce"] = s

	return e
}

func (e *SpanElement) Popover(s string) *SpanElement {
	e.attributes["popover"] = s

	return e
}

func (e *SpanElement) Slot(s string) *SpanElement {
	e.attributes["slot"] = s

	return e
}

func (e *SpanElement) Spellcheck(a SpanSpellcheckEnum) *SpanElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *SpanElement) Style(s string) *SpanElement {
	e.attributes["style"] = s

	return e
}

func (e *SpanElement) Tabindex(i int) *SpanElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *SpanElement) Title(s string) *SpanElement {
	e.attributes["title"] = s

	return e
}

func (e *SpanElement) Translate(a SpanTranslateEnum) *SpanElement {
	e.attributes["translate"] = a

	return e
}

func (e *SpanElement) Writingsuggestions(a SpanWritingsuggestionsEnum) *SpanElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *SpanElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<span")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key))

		// Enum types support empty attributes and can be omitted.
		if fmt.Sprintf("%s", v) == "" {
			w.Write([]byte(" "))
			continue
		}

		w.Write([]byte("="))

		w.Write([]byte("\"" + fmt.Sprintf("%v", v) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}
	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</span>")); err != nil {
		return err
	}

	return nil
}
