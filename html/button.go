// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"slices"
	"strings"

	"github.com/go-htemel/htemel"
	"golang.org/x/net/html"
)

type ButtonElement struct {
	attributes buttonAttrs
	children   []htemel.Node
	skipRender bool
}

// Button creates a tag <button> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The button element represents a button labeled by its contents.
func Button(children ...htemel.Node) *ButtonElement {
	node := &ButtonElement{
		children:   children,
		attributes: make(buttonAttrs),
	}

	return node
}

func ButtonIf(condition bool, children ...htemel.Node) *ButtonElement {
	if condition {
		return Button(children...)
	}

	return &ButtonElement{
		children:   children,
		attributes: make(buttonAttrs),
		skipRender: true,
	}
}

func ButtonTernary(condition bool, true htemel.Node, false htemel.Node) *ButtonElement {
	if condition {
		return Button(true)
	}
	return Button(false)
}

// Children appends children to this element.
func (e *ButtonElement) Children(children ...htemel.Node) *ButtonElement {
	e.children = append(e.children, children...)
	return e
}

// With allows passing a function to modify the element via a closure.
func (e *ButtonElement) With(fn func(*ButtonElement)) *ButtonElement {
	fn(e)
	return e
}

// Text adds a text node to the element.
func (e *ButtonElement) Text(text string) *ButtonElement {
	return e.Children(htemel.Text(text))
}

// Textf adds a text node to the element with the given format string and arguments.
func (e *ButtonElement) Textf(format string, args ...any) *ButtonElement {
	return e.Children(htemel.Text(fmt.Sprintf(format, args...)))
}

// If conditionally adds a child node to the element if the condition is true, otherwise it is a no-op.
func (e *ButtonElement) If(cond bool, child htemel.Node) *ButtonElement {
	if cond {
		return e.Children(child)
	}
	return e
}

func (e *ButtonElement) IfElse(cond bool, then, els htemel.Node) *ButtonElement {
	if cond {
		e.Children(then)
	} else {
		e.Children(els)
	}
	return e
}

// IfThen conditionally calls the given function with the element if the condition is true, otherwise it is a no-op.
func (e *ButtonElement) IfThen(cond bool, fn func(*ButtonElement)) *ButtonElement {
	if cond {
		fn(e)
	}
	return e
}

// AddClass appends a class to the element.
func (e *ButtonElement) AddClass(classes ...string) *ButtonElement {
	current := e.attributes["class"].(string)
	all := append(strings.Fields(current), classes...)
	e.attributes["class"] = strings.Join(all, " ")
	return e
}

// ToggleClass toggles a class on or off.
func (e *ButtonElement) ToggleClass(class string, enable bool) *ButtonElement {
	classes := strings.Fields(e.attributes["class"].(string))
	idx := slices.Index(classes, class)
	if enable && idx == -1 {
		classes = append(classes, class)
	} else if !enable && idx >= 0 {
		classes = slices.Delete(classes, idx, idx+1)
	}
	e.attributes["class"] = strings.Join(classes, " ")
	return e
}

type ButtonCommand string

const (
	ButtonCommandClose         ButtonCommand = "close"
	ButtonCommandHidePopover   ButtonCommand = "hide-popover"
	ButtonCommandRequestClose  ButtonCommand = "request-close"
	ButtonCommandShowModal     ButtonCommand = "show-modal"
	ButtonCommandShowPopover   ButtonCommand = "show-popover"
	ButtonCommandTogglePopover ButtonCommand = "toggle-popover"
)

type ButtonFormmethod string

const (
	ButtonFormmethodDialog ButtonFormmethod = "dialog"
	ButtonFormmethodGet    ButtonFormmethod = "get"
	ButtonFormmethodPost   ButtonFormmethod = "post"
)

type ButtonPopovertargetaction string

const (
	ButtonPopovertargetactionHide   ButtonPopovertargetaction = "hide"
	ButtonPopovertargetactionShow   ButtonPopovertargetaction = "show"
	ButtonPopovertargetactionToggle ButtonPopovertargetaction = "toggle"
)

type ButtonType string

const (
	ButtonTypeButton ButtonType = "button"
	ButtonTypeReset  ButtonType = "reset"
	ButtonTypeSubmit ButtonType = "submit"
)

type ButtonAutocapitalize string

const (
	ButtonAutocapitalizeCharacters ButtonAutocapitalize = "characters"
	ButtonAutocapitalizeNone       ButtonAutocapitalize = "none"
	ButtonAutocapitalizeOff        ButtonAutocapitalize = "off"
	ButtonAutocapitalizeOn         ButtonAutocapitalize = "on"
	ButtonAutocapitalizeSentences  ButtonAutocapitalize = "sentences"
	ButtonAutocapitalizeWords      ButtonAutocapitalize = "words"
)

type ButtonAutocorrect string

const (
	ButtonAutocorrectOn    ButtonAutocorrect = "on"
	ButtonAutocorrectOff   ButtonAutocorrect = "off"
	ButtonAutocorrectEmpty ButtonAutocorrect = ""
)

type ButtonContenteditable string

const (
	ButtonContenteditableTrue          ButtonContenteditable = "true"
	ButtonContenteditableFalse         ButtonContenteditable = "false"
	ButtonContenteditablePlaintextOnly ButtonContenteditable = "plaintext-only"
	ButtonContenteditableEmpty         ButtonContenteditable = ""
)

type ButtonDir string

const (
	ButtonDirAuto ButtonDir = "auto"
	ButtonDirLtr  ButtonDir = "ltr"
	ButtonDirRtl  ButtonDir = "rtl"
)

type ButtonDraggable string

const (
	ButtonDraggableTrue  ButtonDraggable = "true"
	ButtonDraggableFalse ButtonDraggable = "false"
)

type ButtonEnterkeyhint string

const (
	ButtonEnterkeyhintNext     ButtonEnterkeyhint = "next"
	ButtonEnterkeyhintPrevious ButtonEnterkeyhint = "previous"
	ButtonEnterkeyhintSearch   ButtonEnterkeyhint = "search"
	ButtonEnterkeyhintSend     ButtonEnterkeyhint = "send"
	ButtonEnterkeyhintDone     ButtonEnterkeyhint = "done"
	ButtonEnterkeyhintEnter    ButtonEnterkeyhint = "enter"
	ButtonEnterkeyhintGo       ButtonEnterkeyhint = "go"
)

type ButtonHidden string

const (
	ButtonHiddenHidden     ButtonHidden = "hidden"
	ButtonHiddenUntilFound ButtonHidden = "until-found"
	ButtonHiddenEmpty      ButtonHidden = ""
)

type ButtonInputmode string

const (
	ButtonInputmodeUrl     ButtonInputmode = "url"
	ButtonInputmodeDecimal ButtonInputmode = "decimal"
	ButtonInputmodeEmail   ButtonInputmode = "email"
	ButtonInputmodeNone    ButtonInputmode = "none"
	ButtonInputmodeNumeric ButtonInputmode = "numeric"
	ButtonInputmodeSearch  ButtonInputmode = "search"
	ButtonInputmodeTel     ButtonInputmode = "tel"
	ButtonInputmodeText    ButtonInputmode = "text"
)

type ButtonSpellcheck string

const (
	ButtonSpellcheckFalse ButtonSpellcheck = "false"
	ButtonSpellcheckTrue  ButtonSpellcheck = "true"
	ButtonSpellcheckEmpty ButtonSpellcheck = ""
)

type ButtonTranslate string

const (
	ButtonTranslateNo    ButtonTranslate = "no"
	ButtonTranslateYes   ButtonTranslate = "yes"
	ButtonTranslateEmpty ButtonTranslate = ""
)

type ButtonWritingsuggestions string

const (
	ButtonWritingsuggestionsFalse ButtonWritingsuggestions = "false"
	ButtonWritingsuggestionsTrue  ButtonWritingsuggestions = "true"
	ButtonWritingsuggestionsEmpty ButtonWritingsuggestions = ""
)

type buttonAttrs map[string]any

func (e *ButtonElement) Command(a ButtonCommand) *ButtonElement {
	e.attributes["command"] = a

	return e
}

func ButtonCommandCustom(s string) ButtonCommand {
	return ButtonCommand(s)
}

func (e *ButtonElement) Commandfor(s string) *ButtonElement {
	e.attributes["commandfor"] = s

	return e
}

func (e *ButtonElement) Disabled(b bool) *ButtonElement {
	e.attributes["disabled"] = b

	return e
}

func (e *ButtonElement) Form(s string) *ButtonElement {
	e.attributes["form"] = s

	return e
}

func (e *ButtonElement) Formaction(s string) *ButtonElement {
	e.attributes["formaction"] = s

	return e
}

func (e *ButtonElement) Formenctype(s string) *ButtonElement {
	e.attributes["formenctype"] = s

	return e
}

func (e *ButtonElement) Formmethod(a ButtonFormmethod) *ButtonElement {
	e.attributes["formmethod"] = a

	return e
}

func (e *ButtonElement) Formnovalidate(b bool) *ButtonElement {
	e.attributes["formnovalidate"] = b

	return e
}

func (e *ButtonElement) Formtarget(s string) *ButtonElement {
	e.attributes["formtarget"] = s

	return e
}

func (e *ButtonElement) Name(s string) *ButtonElement {
	e.attributes["name"] = s

	return e
}

func (e *ButtonElement) Popovertarget(s string) *ButtonElement {
	e.attributes["popovertarget"] = s

	return e
}

func (e *ButtonElement) Popovertargetaction(a ButtonPopovertargetaction) *ButtonElement {
	e.attributes["popovertargetaction"] = a

	return e
}

func (e *ButtonElement) Type(a ButtonType) *ButtonElement {
	e.attributes["type"] = a

	return e
}

func (e *ButtonElement) Value(s string) *ButtonElement {
	e.attributes["value"] = s

	return e
}

func (e *ButtonElement) AriaUnsafe(name string, s string) *ButtonElement {
	tag := strings.ToLower("aria-" + name)

	e.attributes[tag] = s

	return e
}

func (e *ButtonElement) Aria(name string, s string) *ButtonElement {
	return e.AriaUnsafe(name, html.EscapeString(s))
}

func (e *ButtonElement) Autocapitalize(a ButtonAutocapitalize) *ButtonElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *ButtonElement) Autocorrect(a ButtonAutocorrect) *ButtonElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *ButtonElement) Autofocus(b bool) *ButtonElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *ButtonElement) Class(s ...string) *ButtonElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *ButtonElement) Contenteditable(a ButtonContenteditable) *ButtonElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *ButtonElement) DataUnsafe(name string, s string) *ButtonElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *ButtonElement) Data(name string, s string) *ButtonElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *ButtonElement) Dir(a ButtonDir) *ButtonElement {
	e.attributes["dir"] = a

	return e
}

func (e *ButtonElement) Draggable(a ButtonDraggable) *ButtonElement {
	e.attributes["draggable"] = a

	return e
}

func (e *ButtonElement) Enterkeyhint(a ButtonEnterkeyhint) *ButtonElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *ButtonElement) Hidden(a ButtonHidden) *ButtonElement {
	e.attributes["hidden"] = a

	return e
}

func (e *ButtonElement) Id(s string) *ButtonElement {
	e.attributes["id"] = s

	return e
}

func (e *ButtonElement) Inert(b bool) *ButtonElement {
	e.attributes["inert"] = b

	return e
}

func (e *ButtonElement) Inputmode(a ButtonInputmode) *ButtonElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *ButtonElement) Itemid(s string) *ButtonElement {
	e.attributes["itemid"] = s

	return e
}

func (e *ButtonElement) Itemprop(s ...string) *ButtonElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *ButtonElement) Itemref(s ...string) *ButtonElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *ButtonElement) Itemscope(b bool) *ButtonElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *ButtonElement) Itemtype(s ...string) *ButtonElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *ButtonElement) Lang(s string) *ButtonElement {
	e.attributes["lang"] = s

	return e
}

func (e *ButtonElement) Nonce(s string) *ButtonElement {
	e.attributes["nonce"] = s

	return e
}

func (e *ButtonElement) Popover(s string) *ButtonElement {
	e.attributes["popover"] = s

	return e
}

func (e *ButtonElement) Role(s string) *ButtonElement {
	e.attributes["role"] = s

	return e
}

func (e *ButtonElement) Slot(s string) *ButtonElement {
	e.attributes["slot"] = s

	return e
}

func (e *ButtonElement) Spellcheck(a ButtonSpellcheck) *ButtonElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *ButtonElement) Style(s string) *ButtonElement {
	e.attributes["style"] = s

	return e
}

func (e *ButtonElement) Tabindex(i int) *ButtonElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *ButtonElement) Title(s string) *ButtonElement {
	e.attributes["title"] = s

	return e
}

func (e *ButtonElement) Translate(a ButtonTranslate) *ButtonElement {
	e.attributes["translate"] = a

	return e
}

func (e *ButtonElement) Writingsuggestions(a ButtonWritingsuggestions) *ButtonElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *ButtonElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	var sb strings.Builder
	sb.WriteString("<button")

	for key, v := range e.attributes {
		sb.WriteByte(' ')
		sb.WriteString(key)

		strVal := fmt.Sprintf("%v", v)
		if strVal != "" {
			sb.WriteByte('=')
			sb.WriteByte('"')
			sb.WriteString(strVal)
			sb.WriteByte('"')
		}
	}

	sb.WriteByte('>')
	for _, child := range e.children {
		if err := child.Render(&sb); err != nil {
			return err
		}
	}

	sb.WriteString("</button>")

	_, err := io.WriteString(w, sb.String())
	return err
}
