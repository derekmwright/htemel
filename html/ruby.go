// Code generated by htemel. DO NOT EDIT.
package html

import (
  "fmt"
  "github.com/derekmwright/htemel"
  "golang.org/x/net/html"
  "io"
  "strings"
)

type RubyElement struct {
	attributes rubyAttrs
	children []htemel.Node
	skipRender bool
}

// Ruby creates a tag <ruby> instance and returns it for further modification.
// Any children passed will be nested within the tag.
//
// Spec Description: The ruby element allows one or more spans of phrasing content to be marked with ruby annotations. Ruby annotations are short runs of text presented alongside base text, primarily used in East Asian typography as a guide for pronunciation or to include other annotations. In Japanese, this form of typography is also known as furigana.
func Ruby(children ...htemel.Node) *RubyElement {
	node := &RubyElement{
		children: children,
		attributes: make(rubyAttrs),
	}

	return node
}

func RubyIf(condition bool, children ...htemel.Node) *RubyElement {
	if condition {
		return Ruby(children...)
	}

	return &RubyElement{
		skipRender: true,
	}
}

type RubyAutocapitalizeEnum string

const (
	RubyAutocapitalizeEnumCharacters RubyAutocapitalizeEnum = "characters"
	RubyAutocapitalizeEnumNone RubyAutocapitalizeEnum = "none"
	RubyAutocapitalizeEnumOff RubyAutocapitalizeEnum = "off"
	RubyAutocapitalizeEnumOn RubyAutocapitalizeEnum = "on"
	RubyAutocapitalizeEnumSentences RubyAutocapitalizeEnum = "sentences"
	RubyAutocapitalizeEnumWords RubyAutocapitalizeEnum = "words"
)

type RubyAutocorrectEnum string

const (
	RubyAutocorrectEnumOff RubyAutocorrectEnum = "off"
	RubyAutocorrectEnumOn RubyAutocorrectEnum = "on"
)

type RubyContenteditableEnum string

const (
	RubyContenteditableEnumFalse RubyContenteditableEnum = "false"
	RubyContenteditableEnumPlaintextOnly RubyContenteditableEnum = "plaintext-only"
	RubyContenteditableEnumTrue RubyContenteditableEnum = "true"
)

type RubyDirEnum string

const (
	RubyDirEnumAuto RubyDirEnum = "auto"
	RubyDirEnumLtr RubyDirEnum = "ltr"
	RubyDirEnumRtl RubyDirEnum = "rtl"
)

type RubyDraggableEnum string

const (
	RubyDraggableEnumFalse RubyDraggableEnum = "false"
	RubyDraggableEnumTrue RubyDraggableEnum = "true"
)

type RubyEnterkeyhintEnum string

const (
	RubyEnterkeyhintEnumDone RubyEnterkeyhintEnum = "done"
	RubyEnterkeyhintEnumEnter RubyEnterkeyhintEnum = "enter"
	RubyEnterkeyhintEnumGo RubyEnterkeyhintEnum = "go"
	RubyEnterkeyhintEnumNext RubyEnterkeyhintEnum = "next"
	RubyEnterkeyhintEnumPrevious RubyEnterkeyhintEnum = "previous"
	RubyEnterkeyhintEnumSearch RubyEnterkeyhintEnum = "search"
	RubyEnterkeyhintEnumSend RubyEnterkeyhintEnum = "send"
)

type RubyHiddenEnum string

const (
	RubyHiddenEnumHidden RubyHiddenEnum = "hidden"
	RubyHiddenEnumUntilFound RubyHiddenEnum = "until-found"
)

type rubyAttrs map[string]any

func (e *RubyElement) Autocapitalize(a RubyAutocapitalizeEnum) *RubyElement {
	e.attributes["autocapitalize"] = a
	
	return e
}

func (e *RubyElement) Autocorrect(a RubyAutocorrectEnum) *RubyElement {
	e.attributes["autocorrect"] = a
	
	return e
}

func (e *RubyElement) Autofocus(b bool) *RubyElement {
	e.attributes["autofocus"] = b
	
	return e
}

func (e *RubyElement) Class(s ...string) *RubyElement {
	e.attributes["class"] = strings.Join(s, " ")
	
	return e
}

func (e *RubyElement) Contenteditable(a RubyContenteditableEnum) *RubyElement {
	e.attributes["contenteditable"] = a
	
	return e
}

func (e *RubyElement) Dir(a RubyDirEnum) *RubyElement {
	e.attributes["dir"] = a
	
	return e
}

func (e *RubyElement) Draggable(a RubyDraggableEnum) *RubyElement {
	e.attributes["draggable"] = a
	
	return e
}

func (e *RubyElement) Enterkeyhint(a RubyEnterkeyhintEnum) *RubyElement {
	e.attributes["enterkeyhint"] = a
	
	return e
}

func (e *RubyElement) Hidden(a RubyHiddenEnum) *RubyElement {
	e.attributes["hidden"] = a
	
	return e
}

func (e *RubyElement) Id(s string) *RubyElement {
	e.attributes["id"] = s
	
	return e
}

func (e *RubyElement) Slot(s string) *RubyElement {
	e.attributes["slot"] = s
	
	return e
}

func (e *RubyElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<ruby")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key + "="))
		w.Write([]byte("\"" + html.EscapeString(fmt.Sprintf("%v", v)) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}

	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</ruby>")); err != nil {
		return err
	}

	return nil
}
