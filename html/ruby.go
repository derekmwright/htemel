// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"strings"

	"github.com/derekmwright/htemel"
	"golang.org/x/net/html"
)

type RubyElement struct {
	attributes rubyAttrs
	children   []htemel.Node
	skipRender bool
}

// Ruby creates a tag <ruby> instance and returns it for further modification.
// Any children passed will be nested within the tag.
//
// Spec Description: The ruby element allows one or more spans of phrasing content to be marked with ruby annotations. Ruby annotations are short runs of text presented alongside base text, primarily used in East Asian typography as a guide for pronunciation or to include other annotations. In Japanese, this form of typography is also known as furigana.
func Ruby(children ...htemel.Node) *RubyElement {
	node := &RubyElement{
		children:   children,
		attributes: make(rubyAttrs),
	}

	return node
}

func RubyIf(condition bool, children ...htemel.Node) *RubyElement {
	if condition {
		return Ruby(children...)
	}

	return &RubyElement{
		skipRender: true,
	}
}

type RubyAutocapitalizeAttrEnum string

const (
	RubyAutocapitalizeAttrEnumCharacters RubyAutocapitalizeAttrEnum = "characters"
	RubyAutocapitalizeAttrEnumNone       RubyAutocapitalizeAttrEnum = "none"
	RubyAutocapitalizeAttrEnumOff        RubyAutocapitalizeAttrEnum = "off"
	RubyAutocapitalizeAttrEnumOn         RubyAutocapitalizeAttrEnum = "on"
	RubyAutocapitalizeAttrEnumSentences  RubyAutocapitalizeAttrEnum = "sentences"
	RubyAutocapitalizeAttrEnumWords      RubyAutocapitalizeAttrEnum = "words"
)

type RubyAutocorrectAttrEnum string

const (
	RubyAutocorrectAttrEnumOff RubyAutocorrectAttrEnum = "off"
	RubyAutocorrectAttrEnumOn  RubyAutocorrectAttrEnum = "on"
)

type RubyContenteditableAttrEnum string

const (
	RubyContenteditableAttrEnumFalse         RubyContenteditableAttrEnum = "false"
	RubyContenteditableAttrEnumPlaintextOnly RubyContenteditableAttrEnum = "plaintext-only"
	RubyContenteditableAttrEnumTrue          RubyContenteditableAttrEnum = "true"
)

type rubyAttrs map[string]any

func (e *RubyElement) Autocapitalize(a RubyAutocapitalizeAttrEnum) *RubyElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *RubyElement) Autocorrect(a RubyAutocorrectAttrEnum) *RubyElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *RubyElement) Autofocus(b bool) *RubyElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *RubyElement) Class(s ...string) *RubyElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *RubyElement) Contenteditable(a RubyContenteditableAttrEnum) *RubyElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *RubyElement) Id(s string) *RubyElement {
	e.attributes["id"] = s

	return e
}

func (e *RubyElement) Slot(s string) *RubyElement {
	e.attributes["slot"] = s

	return e
}

func (e *RubyElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<ruby")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key + "="))
		w.Write([]byte("\"" + html.EscapeString(fmt.Sprintf("%v", v)) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}

	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</ruby>")); err != nil {
		return err
	}

	return nil
}
