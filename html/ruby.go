// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"slices"
	"strings"

	"github.com/derekmwright/htemel"
	"golang.org/x/net/html"
)

type RubyElement struct {
	attributes rubyAttrs
	children   []htemel.Node
	skipRender bool
}

// Ruby creates a tag <ruby> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The ruby element allows one or more spans of phrasing content to be marked with ruby annotations. Ruby annotations are short runs of text presented alongside base text, primarily used in East Asian typography as a guide for pronunciation or to include other annotations. In Japanese, this form of typography is also known as furigana.
func Ruby(children ...htemel.Node) *RubyElement {
	node := &RubyElement{
		children:   children,
		attributes: make(rubyAttrs),
	}

	return node
}

func RubyIf(condition bool, children ...htemel.Node) *RubyElement {
	if condition {
		return Ruby(children...)
	}

	return &RubyElement{
		children:   children,
		attributes: make(rubyAttrs),
		skipRender: true,
	}
}

func RubyTernary(condition bool, true htemel.Node, false htemel.Node) *RubyElement {
	if condition {
		return Ruby(true)
	}
	return Ruby(false)
}

// Children appends children to this element.
func (e *RubyElement) Children(children ...htemel.Node) *RubyElement {
	e.children = append(e.children, children...)
	return e
}

// With allows passing a function to modify the element via a closure.
func (e *RubyElement) With(fn func(*RubyElement)) *RubyElement {
	fn(e)
	return e
}

// Text adds a text node to the element.
func (e *RubyElement) Text(text string) *RubyElement {
	return e.Children(htemel.Text(text))
}

// Textf adds a text node to the element with the given format string and arguments.
func (e *RubyElement) Textf(format string, args ...any) *RubyElement {
	return e.Children(htemel.Text(fmt.Sprintf(format, args...)))
}

// If conditionally adds a child node to the element if the condition is true, otherwise it is a no-op.
func (e *RubyElement) If(cond bool, child htemel.Node) *RubyElement {
	if cond {
		return e.Children(child)
	}
	return e
}

func (e *RubyElement) IfElse(cond bool, then, els htemel.Node) *RubyElement {
	if cond {
		e.Children(then)
	} else {
		e.Children(els)
	}
	return e
}

// IfThen conditionally calls the given function with the element if the condition is true, otherwise it is a no-op.
func (e *RubyElement) IfThen(cond bool, fn func(*RubyElement)) *RubyElement {
	if cond {
		fn(e)
	}
	return e
}

// AddClass appends a class to the element.
func (e *RubyElement) AddClass(classes ...string) *RubyElement {
	current := e.attributes["class"].(string)
	all := append(strings.Fields(current), classes...)
	e.attributes["class"] = strings.Join(all, " ")
	return e
}

// ToggleClass toggles a class on or off.
func (e *RubyElement) ToggleClass(class string, enable bool) *RubyElement {
	classes := strings.Fields(e.attributes["class"].(string))
	idx := slices.Index(classes, class)
	if enable && idx == -1 {
		classes = append(classes, class)
	} else if !enable && idx >= 0 {
		classes = slices.Delete(classes, idx, idx+1)
	}
	e.attributes["class"] = strings.Join(classes, " ")
	return e
}

type RubyAutocapitalize string

const (
	RubyAutocapitalizeCharacters RubyAutocapitalize = "characters"
	RubyAutocapitalizeNone       RubyAutocapitalize = "none"
	RubyAutocapitalizeOff        RubyAutocapitalize = "off"
	RubyAutocapitalizeOn         RubyAutocapitalize = "on"
	RubyAutocapitalizeSentences  RubyAutocapitalize = "sentences"
	RubyAutocapitalizeWords      RubyAutocapitalize = "words"
)

type RubyAutocorrect string

const (
	RubyAutocorrectOff   RubyAutocorrect = "off"
	RubyAutocorrectOn    RubyAutocorrect = "on"
	RubyAutocorrectEmpty RubyAutocorrect = ""
)

type RubyContenteditable string

const (
	RubyContenteditablePlaintextOnly RubyContenteditable = "plaintext-only"
	RubyContenteditableTrue          RubyContenteditable = "true"
	RubyContenteditableFalse         RubyContenteditable = "false"
	RubyContenteditableEmpty         RubyContenteditable = ""
)

type RubyDir string

const (
	RubyDirAuto RubyDir = "auto"
	RubyDirLtr  RubyDir = "ltr"
	RubyDirRtl  RubyDir = "rtl"
)

type RubyDraggable string

const (
	RubyDraggableFalse RubyDraggable = "false"
	RubyDraggableTrue  RubyDraggable = "true"
)

type RubyEnterkeyhint string

const (
	RubyEnterkeyhintPrevious RubyEnterkeyhint = "previous"
	RubyEnterkeyhintSearch   RubyEnterkeyhint = "search"
	RubyEnterkeyhintSend     RubyEnterkeyhint = "send"
	RubyEnterkeyhintDone     RubyEnterkeyhint = "done"
	RubyEnterkeyhintEnter    RubyEnterkeyhint = "enter"
	RubyEnterkeyhintGo       RubyEnterkeyhint = "go"
	RubyEnterkeyhintNext     RubyEnterkeyhint = "next"
)

type RubyHidden string

const (
	RubyHiddenHidden     RubyHidden = "hidden"
	RubyHiddenUntilFound RubyHidden = "until-found"
	RubyHiddenEmpty      RubyHidden = ""
)

type RubyInputmode string

const (
	RubyInputmodeEmail   RubyInputmode = "email"
	RubyInputmodeNone    RubyInputmode = "none"
	RubyInputmodeNumeric RubyInputmode = "numeric"
	RubyInputmodeSearch  RubyInputmode = "search"
	RubyInputmodeTel     RubyInputmode = "tel"
	RubyInputmodeText    RubyInputmode = "text"
	RubyInputmodeUrl     RubyInputmode = "url"
	RubyInputmodeDecimal RubyInputmode = "decimal"
)

type RubySpellcheck string

const (
	RubySpellcheckFalse RubySpellcheck = "false"
	RubySpellcheckTrue  RubySpellcheck = "true"
	RubySpellcheckEmpty RubySpellcheck = ""
)

type RubyTranslate string

const (
	RubyTranslateNo    RubyTranslate = "no"
	RubyTranslateYes   RubyTranslate = "yes"
	RubyTranslateEmpty RubyTranslate = ""
)

type RubyWritingsuggestions string

const (
	RubyWritingsuggestionsFalse RubyWritingsuggestions = "false"
	RubyWritingsuggestionsTrue  RubyWritingsuggestions = "true"
	RubyWritingsuggestionsEmpty RubyWritingsuggestions = ""
)

type rubyAttrs map[string]any

func (e *RubyElement) AriaUnsafe(name string, s string) *RubyElement {
	tag := strings.ToLower("aria-" + name)

	e.attributes[tag] = s

	return e
}

func (e *RubyElement) Aria(name string, s string) *RubyElement {
	return e.AriaUnsafe(name, html.EscapeString(s))
}

func (e *RubyElement) Autocapitalize(a RubyAutocapitalize) *RubyElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *RubyElement) Autocorrect(a RubyAutocorrect) *RubyElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *RubyElement) Autofocus(b bool) *RubyElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *RubyElement) Class(s ...string) *RubyElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *RubyElement) Contenteditable(a RubyContenteditable) *RubyElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *RubyElement) DataUnsafe(name string, s string) *RubyElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *RubyElement) Data(name string, s string) *RubyElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *RubyElement) Dir(a RubyDir) *RubyElement {
	e.attributes["dir"] = a

	return e
}

func (e *RubyElement) Draggable(a RubyDraggable) *RubyElement {
	e.attributes["draggable"] = a

	return e
}

func (e *RubyElement) Enterkeyhint(a RubyEnterkeyhint) *RubyElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *RubyElement) Hidden(a RubyHidden) *RubyElement {
	e.attributes["hidden"] = a

	return e
}

func (e *RubyElement) Id(s string) *RubyElement {
	e.attributes["id"] = s

	return e
}

func (e *RubyElement) Inert(b bool) *RubyElement {
	e.attributes["inert"] = b

	return e
}

func (e *RubyElement) Inputmode(a RubyInputmode) *RubyElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *RubyElement) Itemid(s string) *RubyElement {
	e.attributes["itemid"] = s

	return e
}

func (e *RubyElement) Itemprop(s ...string) *RubyElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *RubyElement) Itemref(s ...string) *RubyElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *RubyElement) Itemscope(b bool) *RubyElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *RubyElement) Itemtype(s ...string) *RubyElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *RubyElement) Lang(s string) *RubyElement {
	e.attributes["lang"] = s

	return e
}

func (e *RubyElement) Nonce(s string) *RubyElement {
	e.attributes["nonce"] = s

	return e
}

func (e *RubyElement) Popover(s string) *RubyElement {
	e.attributes["popover"] = s

	return e
}

func (e *RubyElement) Role(s string) *RubyElement {
	e.attributes["role"] = s

	return e
}

func (e *RubyElement) Slot(s string) *RubyElement {
	e.attributes["slot"] = s

	return e
}

func (e *RubyElement) Spellcheck(a RubySpellcheck) *RubyElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *RubyElement) Style(s string) *RubyElement {
	e.attributes["style"] = s

	return e
}

func (e *RubyElement) Tabindex(i int) *RubyElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *RubyElement) Title(s string) *RubyElement {
	e.attributes["title"] = s

	return e
}

func (e *RubyElement) Translate(a RubyTranslate) *RubyElement {
	e.attributes["translate"] = a

	return e
}

func (e *RubyElement) Writingsuggestions(a RubyWritingsuggestions) *RubyElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *RubyElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	var sb strings.Builder
	sb.WriteString("<ruby")

	for key, v := range e.attributes {
		sb.WriteByte(' ')
		sb.WriteString(key)

		strVal := fmt.Sprintf("%v", v)
		if strVal != "" {
			sb.WriteByte('=')
			sb.WriteByte('"')
			sb.WriteString(strVal)
			sb.WriteByte('"')
		}
	}

	sb.WriteByte('>')
	for _, child := range e.children {
		if err := child.Render(&sb); err != nil {
			return err
		}
	}

	sb.WriteString("</ruby>")

	_, err := io.WriteString(w, sb.String())
	return err
}
