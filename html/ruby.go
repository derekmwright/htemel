// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"strings"

	"github.com/derekmwright/htemel"
	"golang.org/x/net/html"
)

type RubyElement struct {
	attributes rubyAttrs
	children   []htemel.Node
	skipRender bool
}

// Ruby creates a tag <ruby> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The ruby element allows one or more spans of phrasing content to be marked with ruby annotations. Ruby annotations are short runs of text presented alongside base text, primarily used in East Asian typography as a guide for pronunciation or to include other annotations. In Japanese, this form of typography is also known as furigana.
func Ruby(children ...htemel.Node) *RubyElement {
	node := &RubyElement{
		children:   children,
		attributes: make(rubyAttrs),
	}

	return node
}

func RubyIf(condition bool, children ...htemel.Node) *RubyElement {
	if condition {
		return Ruby(children...)
	}

	return &RubyElement{
		children:   children,
		attributes: make(rubyAttrs),
		skipRender: true,
	}
}

func RubyTernary(condition bool, true htemel.Node, false htemel.Node) *RubyElement {
	if condition {
		return Ruby(true)
	}

	return Ruby(false)
}

type RubyAutocapitalize string

const (
	RubyAutocapitalizeOff        RubyAutocapitalize = "off"
	RubyAutocapitalizeOn         RubyAutocapitalize = "on"
	RubyAutocapitalizeSentences  RubyAutocapitalize = "sentences"
	RubyAutocapitalizeWords      RubyAutocapitalize = "words"
	RubyAutocapitalizeCharacters RubyAutocapitalize = "characters"
	RubyAutocapitalizeNone       RubyAutocapitalize = "none"
)

type RubyAutocorrect string

const (
	RubyAutocorrectOn    RubyAutocorrect = "on"
	RubyAutocorrectOff   RubyAutocorrect = "off"
	RubyAutocorrectEmpty RubyAutocorrect = ""
)

type RubyContenteditable string

const (
	RubyContenteditableFalse         RubyContenteditable = "false"
	RubyContenteditablePlaintextOnly RubyContenteditable = "plaintext-only"
	RubyContenteditableTrue          RubyContenteditable = "true"
	RubyContenteditableEmpty         RubyContenteditable = ""
)

type RubyDir string

const (
	RubyDirAuto RubyDir = "auto"
	RubyDirLtr  RubyDir = "ltr"
	RubyDirRtl  RubyDir = "rtl"
)

type RubyDraggable string

const (
	RubyDraggableFalse RubyDraggable = "false"
	RubyDraggableTrue  RubyDraggable = "true"
)

type RubyEnterkeyhint string

const (
	RubyEnterkeyhintDone     RubyEnterkeyhint = "done"
	RubyEnterkeyhintEnter    RubyEnterkeyhint = "enter"
	RubyEnterkeyhintGo       RubyEnterkeyhint = "go"
	RubyEnterkeyhintNext     RubyEnterkeyhint = "next"
	RubyEnterkeyhintPrevious RubyEnterkeyhint = "previous"
	RubyEnterkeyhintSearch   RubyEnterkeyhint = "search"
	RubyEnterkeyhintSend     RubyEnterkeyhint = "send"
)

type RubyHidden string

const (
	RubyHiddenUntilFound RubyHidden = "until-found"
	RubyHiddenHidden     RubyHidden = "hidden"
	RubyHiddenEmpty      RubyHidden = ""
)

type RubyInputmode string

const (
	RubyInputmodeDecimal RubyInputmode = "decimal"
	RubyInputmodeEmail   RubyInputmode = "email"
	RubyInputmodeNone    RubyInputmode = "none"
	RubyInputmodeNumeric RubyInputmode = "numeric"
	RubyInputmodeSearch  RubyInputmode = "search"
	RubyInputmodeTel     RubyInputmode = "tel"
	RubyInputmodeText    RubyInputmode = "text"
	RubyInputmodeUrl     RubyInputmode = "url"
)

type RubySpellcheck string

const (
	RubySpellcheckFalse RubySpellcheck = "false"
	RubySpellcheckTrue  RubySpellcheck = "true"
	RubySpellcheckEmpty RubySpellcheck = ""
)

type RubyTranslate string

const (
	RubyTranslateNo    RubyTranslate = "no"
	RubyTranslateYes   RubyTranslate = "yes"
	RubyTranslateEmpty RubyTranslate = ""
)

type RubyWritingsuggestions string

const (
	RubyWritingsuggestionsFalse RubyWritingsuggestions = "false"
	RubyWritingsuggestionsTrue  RubyWritingsuggestions = "true"
	RubyWritingsuggestionsEmpty RubyWritingsuggestions = ""
)

type rubyAttrs map[string]any

func (e *RubyElement) AriaUnsafe(name string, s string) *RubyElement {
	tag := strings.ToLower("aria-" + name)

	e.attributes[tag] = s

	return e
}

func (e *RubyElement) Aria(name string, s string) *RubyElement {
	return e.AriaUnsafe(name, html.EscapeString(s))
}

func (e *RubyElement) Autocapitalize(a RubyAutocapitalize) *RubyElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *RubyElement) Autocorrect(a RubyAutocorrect) *RubyElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *RubyElement) Autofocus(b bool) *RubyElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *RubyElement) Class(s ...string) *RubyElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *RubyElement) Contenteditable(a RubyContenteditable) *RubyElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *RubyElement) DataUnsafe(name string, s string) *RubyElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *RubyElement) Data(name string, s string) *RubyElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *RubyElement) Dir(a RubyDir) *RubyElement {
	e.attributes["dir"] = a

	return e
}

func (e *RubyElement) Draggable(a RubyDraggable) *RubyElement {
	e.attributes["draggable"] = a

	return e
}

func (e *RubyElement) Enterkeyhint(a RubyEnterkeyhint) *RubyElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *RubyElement) Hidden(a RubyHidden) *RubyElement {
	e.attributes["hidden"] = a

	return e
}

func (e *RubyElement) Id(s string) *RubyElement {
	e.attributes["id"] = s

	return e
}

func (e *RubyElement) Inert(b bool) *RubyElement {
	e.attributes["inert"] = b

	return e
}

func (e *RubyElement) Inputmode(a RubyInputmode) *RubyElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *RubyElement) Itemid(s string) *RubyElement {
	e.attributes["itemid"] = s

	return e
}

func (e *RubyElement) Itemprop(s ...string) *RubyElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *RubyElement) Itemref(s ...string) *RubyElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *RubyElement) Itemscope(b bool) *RubyElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *RubyElement) Itemtype(s ...string) *RubyElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *RubyElement) Lang(s string) *RubyElement {
	e.attributes["lang"] = s

	return e
}

func (e *RubyElement) Nonce(s string) *RubyElement {
	e.attributes["nonce"] = s

	return e
}

func (e *RubyElement) Popover(s string) *RubyElement {
	e.attributes["popover"] = s

	return e
}

func (e *RubyElement) Role(s string) *RubyElement {
	e.attributes["role"] = s

	return e
}

func (e *RubyElement) Slot(s string) *RubyElement {
	e.attributes["slot"] = s

	return e
}

func (e *RubyElement) Spellcheck(a RubySpellcheck) *RubyElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *RubyElement) Style(s string) *RubyElement {
	e.attributes["style"] = s

	return e
}

func (e *RubyElement) Tabindex(i int) *RubyElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *RubyElement) Title(s string) *RubyElement {
	e.attributes["title"] = s

	return e
}

func (e *RubyElement) Translate(a RubyTranslate) *RubyElement {
	e.attributes["translate"] = a

	return e
}

func (e *RubyElement) Writingsuggestions(a RubyWritingsuggestions) *RubyElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *RubyElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<ruby")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key))

		// Enum types support empty attributes and can be omitted.
		if fmt.Sprintf("%s", v) == "" {
			w.Write([]byte(" "))
			continue
		}

		w.Write([]byte("="))

		w.Write([]byte("\"" + fmt.Sprintf("%v", v) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}
	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</ruby>")); err != nil {
		return err
	}

	return nil
}
