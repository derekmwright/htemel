// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"slices"
	"strings"

	"github.com/derekmwright/htemel"
	"golang.org/x/net/html"
)

type MarkElement struct {
	attributes markAttrs
	children   []htemel.Node
	skipRender bool
}

// Mark creates a tag <mark> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The mark element represents a run of text in one document marked or highlighted for reference purposes, due to its relevance in another context. When used in a quotation or other block of text referred to from the prose, it indicates a highlight that was not originally present but which has been added to bring the reader's attention to a part of the text that might not have been considered important by the original author when the block was originally written, but which is now under previously unexpected scrutiny. When used in the main prose of a document, it indicates a part of the document that has been highlighted due to its likely relevance to the user's current activity.
func Mark(children ...htemel.Node) *MarkElement {
	node := &MarkElement{
		children:   children,
		attributes: make(markAttrs),
	}

	return node
}

func MarkIf(condition bool, children ...htemel.Node) *MarkElement {
	if condition {
		return Mark(children...)
	}

	return &MarkElement{
		children:   children,
		attributes: make(markAttrs),
		skipRender: true,
	}
}

func MarkTernary(condition bool, true htemel.Node, false htemel.Node) *MarkElement {
	if condition {
		return Mark(true)
	}
	return Mark(false)
}

// Children appends children to this element.
func (e *MarkElement) Children(children ...htemel.Node) *MarkElement {
	e.children = append(e.children, children...)
	return e
}

// With allows passing a function to modify the element via a closure.
func (e *MarkElement) With(fn func(*MarkElement)) *MarkElement {
	fn(e)
	return e
}

// Text adds a text node to the element.
func (e *MarkElement) Text(text string) *MarkElement {
	return e.Children(htemel.Text(text))
}

// Textf adds a text node to the element with the given format string and arguments.
func (e *MarkElement) Textf(format string, args ...any) *MarkElement {
	return e.Children(htemel.Text(fmt.Sprintf(format, args...)))
}

// AddClass appends a class to the element.
func (e *MarkElement) AddClass(classes ...string) *MarkElement {
	current := e.attributes["class"].(string)
	all := append(strings.Fields(current), classes...)
	e.attributes["class"] = strings.Join(all, " ")
	return e
}

// ToggleClass toggles a class on or off.
func (e *MarkElement) ToggleClass(class string, enable bool) *MarkElement {
	classes := strings.Fields(e.attributes["class"].(string))
	idx := slices.Index(classes, class)
	if enable && idx == -1 {
		classes = append(classes, class)
	} else if !enable && idx >= 0 {
		classes = slices.Delete(classes, idx, idx+1)
	}
	e.attributes["class"] = strings.Join(classes, " ")
	return e
}

type MarkAutocapitalize string

const (
	MarkAutocapitalizeCharacters MarkAutocapitalize = "characters"
	MarkAutocapitalizeNone       MarkAutocapitalize = "none"
	MarkAutocapitalizeOff        MarkAutocapitalize = "off"
	MarkAutocapitalizeOn         MarkAutocapitalize = "on"
	MarkAutocapitalizeSentences  MarkAutocapitalize = "sentences"
	MarkAutocapitalizeWords      MarkAutocapitalize = "words"
)

type MarkAutocorrect string

const (
	MarkAutocorrectOff   MarkAutocorrect = "off"
	MarkAutocorrectOn    MarkAutocorrect = "on"
	MarkAutocorrectEmpty MarkAutocorrect = ""
)

type MarkContenteditable string

const (
	MarkContenteditableTrue          MarkContenteditable = "true"
	MarkContenteditableFalse         MarkContenteditable = "false"
	MarkContenteditablePlaintextOnly MarkContenteditable = "plaintext-only"
	MarkContenteditableEmpty         MarkContenteditable = ""
)

type MarkDir string

const (
	MarkDirAuto MarkDir = "auto"
	MarkDirLtr  MarkDir = "ltr"
	MarkDirRtl  MarkDir = "rtl"
)

type MarkDraggable string

const (
	MarkDraggableFalse MarkDraggable = "false"
	MarkDraggableTrue  MarkDraggable = "true"
)

type MarkEnterkeyhint string

const (
	MarkEnterkeyhintDone     MarkEnterkeyhint = "done"
	MarkEnterkeyhintEnter    MarkEnterkeyhint = "enter"
	MarkEnterkeyhintGo       MarkEnterkeyhint = "go"
	MarkEnterkeyhintNext     MarkEnterkeyhint = "next"
	MarkEnterkeyhintPrevious MarkEnterkeyhint = "previous"
	MarkEnterkeyhintSearch   MarkEnterkeyhint = "search"
	MarkEnterkeyhintSend     MarkEnterkeyhint = "send"
)

type MarkHidden string

const (
	MarkHiddenHidden     MarkHidden = "hidden"
	MarkHiddenUntilFound MarkHidden = "until-found"
	MarkHiddenEmpty      MarkHidden = ""
)

type MarkInputmode string

const (
	MarkInputmodeDecimal MarkInputmode = "decimal"
	MarkInputmodeEmail   MarkInputmode = "email"
	MarkInputmodeNone    MarkInputmode = "none"
	MarkInputmodeNumeric MarkInputmode = "numeric"
	MarkInputmodeSearch  MarkInputmode = "search"
	MarkInputmodeTel     MarkInputmode = "tel"
	MarkInputmodeText    MarkInputmode = "text"
	MarkInputmodeUrl     MarkInputmode = "url"
)

type MarkSpellcheck string

const (
	MarkSpellcheckFalse MarkSpellcheck = "false"
	MarkSpellcheckTrue  MarkSpellcheck = "true"
	MarkSpellcheckEmpty MarkSpellcheck = ""
)

type MarkTranslate string

const (
	MarkTranslateNo    MarkTranslate = "no"
	MarkTranslateYes   MarkTranslate = "yes"
	MarkTranslateEmpty MarkTranslate = ""
)

type MarkWritingsuggestions string

const (
	MarkWritingsuggestionsFalse MarkWritingsuggestions = "false"
	MarkWritingsuggestionsTrue  MarkWritingsuggestions = "true"
	MarkWritingsuggestionsEmpty MarkWritingsuggestions = ""
)

type markAttrs map[string]any

func (e *MarkElement) AriaUnsafe(name string, s string) *MarkElement {
	tag := strings.ToLower("aria-" + name)

	e.attributes[tag] = s

	return e
}

func (e *MarkElement) Aria(name string, s string) *MarkElement {
	return e.AriaUnsafe(name, html.EscapeString(s))
}

func (e *MarkElement) Autocapitalize(a MarkAutocapitalize) *MarkElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *MarkElement) Autocorrect(a MarkAutocorrect) *MarkElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *MarkElement) Autofocus(b bool) *MarkElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *MarkElement) Class(s ...string) *MarkElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *MarkElement) Contenteditable(a MarkContenteditable) *MarkElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *MarkElement) DataUnsafe(name string, s string) *MarkElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *MarkElement) Data(name string, s string) *MarkElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *MarkElement) Dir(a MarkDir) *MarkElement {
	e.attributes["dir"] = a

	return e
}

func (e *MarkElement) Draggable(a MarkDraggable) *MarkElement {
	e.attributes["draggable"] = a

	return e
}

func (e *MarkElement) Enterkeyhint(a MarkEnterkeyhint) *MarkElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *MarkElement) Hidden(a MarkHidden) *MarkElement {
	e.attributes["hidden"] = a

	return e
}

func (e *MarkElement) Id(s string) *MarkElement {
	e.attributes["id"] = s

	return e
}

func (e *MarkElement) Inert(b bool) *MarkElement {
	e.attributes["inert"] = b

	return e
}

func (e *MarkElement) Inputmode(a MarkInputmode) *MarkElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *MarkElement) Itemid(s string) *MarkElement {
	e.attributes["itemid"] = s

	return e
}

func (e *MarkElement) Itemprop(s ...string) *MarkElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *MarkElement) Itemref(s ...string) *MarkElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *MarkElement) Itemscope(b bool) *MarkElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *MarkElement) Itemtype(s ...string) *MarkElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *MarkElement) Lang(s string) *MarkElement {
	e.attributes["lang"] = s

	return e
}

func (e *MarkElement) Nonce(s string) *MarkElement {
	e.attributes["nonce"] = s

	return e
}

func (e *MarkElement) Popover(s string) *MarkElement {
	e.attributes["popover"] = s

	return e
}

func (e *MarkElement) Role(s string) *MarkElement {
	e.attributes["role"] = s

	return e
}

func (e *MarkElement) Slot(s string) *MarkElement {
	e.attributes["slot"] = s

	return e
}

func (e *MarkElement) Spellcheck(a MarkSpellcheck) *MarkElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *MarkElement) Style(s string) *MarkElement {
	e.attributes["style"] = s

	return e
}

func (e *MarkElement) Tabindex(i int) *MarkElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *MarkElement) Title(s string) *MarkElement {
	e.attributes["title"] = s

	return e
}

func (e *MarkElement) Translate(a MarkTranslate) *MarkElement {
	e.attributes["translate"] = a

	return e
}

func (e *MarkElement) Writingsuggestions(a MarkWritingsuggestions) *MarkElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *MarkElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	var sb strings.Builder
	sb.WriteString("<mark")

	for key, v := range e.attributes {
		sb.WriteByte(' ')
		sb.WriteString(key)

		strVal := fmt.Sprintf("%v", v)
		if strVal != "" {
			sb.WriteByte('=')
			sb.WriteByte('"')
			sb.WriteString(strVal)
			sb.WriteByte('"')
		}
	}

	sb.WriteByte('>')
	for _, child := range e.children {
		if err := child.Render(&sb); err != nil {
			return err
		}
	}

	sb.WriteString("</mark>")

	_, err := io.WriteString(w, sb.String())
	return err
}
