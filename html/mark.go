// Code generated by htemel. DO NOT EDIT.
package html

import (
  "fmt"
  "github.com/derekmwright/htemel"
  "golang.org/x/net/html"
  "io"
)

type MarkElement struct {
	attributes markAttrs
	children []htemel.Node
	skipRender bool
}

// Mark creates a tag <mark> instance and returns it for further modification.
// Any children passed will be nested within the tag.
//
// Spec Description: The mark element represents a run of text in one document marked or highlighted for reference purposes, due to its relevance in another context. When used in a quotation or other block of text referred to from the prose, it indicates a highlight that was not originally present but which has been added to bring the reader's attention to a part of the text that might not have been considered important by the original author when the block was originally written, but which is now under previously unexpected scrutiny. When used in the main prose of a document, it indicates a part of the document that has been highlighted due to its likely relevance to the user's current activity.
func Mark(children ...htemel.Node) *MarkElement {
	node := &MarkElement{
		children: children,
	}

	return node
}

func MarkIf(condition bool, children ...htemel.Node) *MarkElement {
	if condition {
		return Mark(children...)
	}

	return &MarkElement{
		skipRender: true,
	}
}

type MarkAutocapitalizeAttrEnum string

const (
	MarkAutocapitalizeAttrEnumOff MarkAutocapitalizeAttrEnum = "off"
	MarkAutocapitalizeAttrEnumOn MarkAutocapitalizeAttrEnum = "on"
	MarkAutocapitalizeAttrEnumSentences MarkAutocapitalizeAttrEnum = "sentences"
	MarkAutocapitalizeAttrEnumWords MarkAutocapitalizeAttrEnum = "words"
	MarkAutocapitalizeAttrEnumCharacters MarkAutocapitalizeAttrEnum = "characters"
	MarkAutocapitalizeAttrEnumNone MarkAutocapitalizeAttrEnum = "none"
)

type MarkAutocorrectAttrEnum string

const (
	MarkAutocorrectAttrEnumOff MarkAutocorrectAttrEnum = "off"
	MarkAutocorrectAttrEnumOn MarkAutocorrectAttrEnum = "on"
)

type MarkContenteditableAttrEnum string

const (
	MarkContenteditableAttrEnumPlaintextOnly MarkContenteditableAttrEnum = "plaintext-only"
	MarkContenteditableAttrEnumTrue MarkContenteditableAttrEnum = "true"
	MarkContenteditableAttrEnumFalse MarkContenteditableAttrEnum = "false"
)

type markAttrs map[string]any

func (e *MarkElement) Autocapitalize(a MarkAutocapitalizeAttrEnum) *MarkElement {
	e.attributes["autocapitalize"] = a
	
	return e
}

func (e *MarkElement) Autocorrect(a MarkAutocorrectAttrEnum) *MarkElement {
	e.attributes["autocorrect"] = a
	
	return e
}

func (e *MarkElement) Class(s ...string) *MarkElement {
	e.attributes["class"] = strings.Join(s, " ")
	
	return e
}

func (e *MarkElement) Contenteditable(a MarkContenteditableAttrEnum) *MarkElement {
	e.attributes["contenteditable"] = a
	
	return e
}

func (e *MarkElement) Id(s string) *MarkElement {
	e.attributes["id"] = s
	
	return e
}

func (e *MarkElement) Slot(s string) *MarkElement {
	e.attributes["slot"] = s
	
	return e
}

func (e *MarkElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<mark")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 0
	for key, v := range e.attributes {
		w.Write([]byte(key + "="))
		w.Write([]byte(html.EscapeString(fmt.Sprintf("'%v'", v))))
		if i < c {
			w.Write([]byte(" "))
		}
		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}

	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</mark>")); err != nil {
		return err
	}

	return nil
}
