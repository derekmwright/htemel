// Code generated by htemel. DO NOT EDIT.
package html

import (
	"fmt"
	"io"
	"strings"

	"github.com/derekmwright/htemel"
	"golang.org/x/net/html"
)

type MarkElement struct {
	attributes markAttrs
	children   []htemel.Node
	skipRender bool
}

// Mark creates a tag <mark> instance and returns it for further modification.
// Any children passed will be nested within the tag.//
// Spec Description: The mark element represents a run of text in one document marked or highlighted for reference purposes, due to its relevance in another context. When used in a quotation or other block of text referred to from the prose, it indicates a highlight that was not originally present but which has been added to bring the reader's attention to a part of the text that might not have been considered important by the original author when the block was originally written, but which is now under previously unexpected scrutiny. When used in the main prose of a document, it indicates a part of the document that has been highlighted due to its likely relevance to the user's current activity.
func Mark(children ...htemel.Node) *MarkElement {
	node := &MarkElement{
		children:   children,
		attributes: make(markAttrs),
	}

	return node
}

func MarkIf(condition bool, children ...htemel.Node) *MarkElement {
	if condition {
		return Mark(children...)
	}

	return &MarkElement{
		children:   children,
		attributes: make(markAttrs),
		skipRender: true,
	}
}

func MarkTernary(condition bool, true htemel.Node, false htemel.Node) *MarkElement {
	if condition {
		return Mark(true)
	}

	return Mark(false)
}

// Children appends children to this element.
func (e *MarkElement) Children(children ...htemel.Node) *MarkElement {
	e.children = append(e.children, children...)

	return e
}

type MarkAutocapitalize string

const (
	MarkAutocapitalizeCharacters MarkAutocapitalize = "characters"
	MarkAutocapitalizeNone       MarkAutocapitalize = "none"
	MarkAutocapitalizeOff        MarkAutocapitalize = "off"
	MarkAutocapitalizeOn         MarkAutocapitalize = "on"
	MarkAutocapitalizeSentences  MarkAutocapitalize = "sentences"
	MarkAutocapitalizeWords      MarkAutocapitalize = "words"
)

type MarkAutocorrect string

const (
	MarkAutocorrectOff   MarkAutocorrect = "off"
	MarkAutocorrectOn    MarkAutocorrect = "on"
	MarkAutocorrectEmpty MarkAutocorrect = ""
)

type MarkContenteditable string

const (
	MarkContenteditableFalse         MarkContenteditable = "false"
	MarkContenteditablePlaintextOnly MarkContenteditable = "plaintext-only"
	MarkContenteditableTrue          MarkContenteditable = "true"
	MarkContenteditableEmpty         MarkContenteditable = ""
)

type MarkDir string

const (
	MarkDirAuto MarkDir = "auto"
	MarkDirLtr  MarkDir = "ltr"
	MarkDirRtl  MarkDir = "rtl"
)

type MarkDraggable string

const (
	MarkDraggableTrue  MarkDraggable = "true"
	MarkDraggableFalse MarkDraggable = "false"
)

type MarkEnterkeyhint string

const (
	MarkEnterkeyhintGo       MarkEnterkeyhint = "go"
	MarkEnterkeyhintNext     MarkEnterkeyhint = "next"
	MarkEnterkeyhintPrevious MarkEnterkeyhint = "previous"
	MarkEnterkeyhintSearch   MarkEnterkeyhint = "search"
	MarkEnterkeyhintSend     MarkEnterkeyhint = "send"
	MarkEnterkeyhintDone     MarkEnterkeyhint = "done"
	MarkEnterkeyhintEnter    MarkEnterkeyhint = "enter"
)

type MarkHidden string

const (
	MarkHiddenHidden     MarkHidden = "hidden"
	MarkHiddenUntilFound MarkHidden = "until-found"
	MarkHiddenEmpty      MarkHidden = ""
)

type MarkInputmode string

const (
	MarkInputmodeNumeric MarkInputmode = "numeric"
	MarkInputmodeSearch  MarkInputmode = "search"
	MarkInputmodeTel     MarkInputmode = "tel"
	MarkInputmodeText    MarkInputmode = "text"
	MarkInputmodeUrl     MarkInputmode = "url"
	MarkInputmodeDecimal MarkInputmode = "decimal"
	MarkInputmodeEmail   MarkInputmode = "email"
	MarkInputmodeNone    MarkInputmode = "none"
)

type MarkSpellcheck string

const (
	MarkSpellcheckFalse MarkSpellcheck = "false"
	MarkSpellcheckTrue  MarkSpellcheck = "true"
	MarkSpellcheckEmpty MarkSpellcheck = ""
)

type MarkTranslate string

const (
	MarkTranslateNo    MarkTranslate = "no"
	MarkTranslateYes   MarkTranslate = "yes"
	MarkTranslateEmpty MarkTranslate = ""
)

type MarkWritingsuggestions string

const (
	MarkWritingsuggestionsTrue  MarkWritingsuggestions = "true"
	MarkWritingsuggestionsFalse MarkWritingsuggestions = "false"
	MarkWritingsuggestionsEmpty MarkWritingsuggestions = ""
)

type markAttrs map[string]any

func (e *MarkElement) AriaUnsafe(name string, s string) *MarkElement {
	tag := strings.ToLower("aria-" + name)

	e.attributes[tag] = s

	return e
}

func (e *MarkElement) Aria(name string, s string) *MarkElement {
	return e.AriaUnsafe(name, html.EscapeString(s))
}

func (e *MarkElement) Autocapitalize(a MarkAutocapitalize) *MarkElement {
	e.attributes["autocapitalize"] = a

	return e
}

func (e *MarkElement) Autocorrect(a MarkAutocorrect) *MarkElement {
	e.attributes["autocorrect"] = a

	return e
}

func (e *MarkElement) Autofocus(b bool) *MarkElement {
	e.attributes["autofocus"] = b

	return e
}

func (e *MarkElement) Class(s ...string) *MarkElement {
	e.attributes["class"] = strings.Join(s, " ")

	return e
}

func (e *MarkElement) Contenteditable(a MarkContenteditable) *MarkElement {
	e.attributes["contenteditable"] = a

	return e
}

func (e *MarkElement) DataUnsafe(name string, s string) *MarkElement {
	tag := strings.ToLower("data-" + name)

	e.attributes[tag] = s

	return e
}

func (e *MarkElement) Data(name string, s string) *MarkElement {
	return e.DataUnsafe(name, html.EscapeString(s))
}

func (e *MarkElement) Dir(a MarkDir) *MarkElement {
	e.attributes["dir"] = a

	return e
}

func (e *MarkElement) Draggable(a MarkDraggable) *MarkElement {
	e.attributes["draggable"] = a

	return e
}

func (e *MarkElement) Enterkeyhint(a MarkEnterkeyhint) *MarkElement {
	e.attributes["enterkeyhint"] = a

	return e
}

func (e *MarkElement) Hidden(a MarkHidden) *MarkElement {
	e.attributes["hidden"] = a

	return e
}

func (e *MarkElement) Id(s string) *MarkElement {
	e.attributes["id"] = s

	return e
}

func (e *MarkElement) Inert(b bool) *MarkElement {
	e.attributes["inert"] = b

	return e
}

func (e *MarkElement) Inputmode(a MarkInputmode) *MarkElement {
	e.attributes["inputmode"] = a

	return e
}

func (e *MarkElement) Itemid(s string) *MarkElement {
	e.attributes["itemid"] = s

	return e
}

func (e *MarkElement) Itemprop(s ...string) *MarkElement {
	e.attributes["itemprop"] = strings.Join(s, " ")

	return e
}

func (e *MarkElement) Itemref(s ...string) *MarkElement {
	e.attributes["itemref"] = strings.Join(s, " ")

	return e
}

func (e *MarkElement) Itemscope(b bool) *MarkElement {
	e.attributes["itemscope"] = b

	return e
}

func (e *MarkElement) Itemtype(s ...string) *MarkElement {
	e.attributes["itemtype"] = strings.Join(s, " ")

	return e
}

func (e *MarkElement) Lang(s string) *MarkElement {
	e.attributes["lang"] = s

	return e
}

func (e *MarkElement) Nonce(s string) *MarkElement {
	e.attributes["nonce"] = s

	return e
}

func (e *MarkElement) Popover(s string) *MarkElement {
	e.attributes["popover"] = s

	return e
}

func (e *MarkElement) Role(s string) *MarkElement {
	e.attributes["role"] = s

	return e
}

func (e *MarkElement) Slot(s string) *MarkElement {
	e.attributes["slot"] = s

	return e
}

func (e *MarkElement) Spellcheck(a MarkSpellcheck) *MarkElement {
	e.attributes["spellcheck"] = a

	return e
}

func (e *MarkElement) Style(s string) *MarkElement {
	e.attributes["style"] = s

	return e
}

func (e *MarkElement) Tabindex(i int) *MarkElement {
	e.attributes["tabindex"] = i

	return e
}

func (e *MarkElement) Title(s string) *MarkElement {
	e.attributes["title"] = s

	return e
}

func (e *MarkElement) Translate(a MarkTranslate) *MarkElement {
	e.attributes["translate"] = a

	return e
}

func (e *MarkElement) Writingsuggestions(a MarkWritingsuggestions) *MarkElement {
	e.attributes["writingsuggestions"] = a

	return e
}

// Render processes the current element, and writes the initial tag.
// Then all children are processed and included within the tag.
// Finally, the tag is closed.
//
// *Except for void elements as they are self closing and do not contain children.
func (e *MarkElement) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<mark")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key))

		// Enum types support empty attributes and can be omitted.
		if fmt.Sprintf("%s", v) == "" {
			w.Write([]byte(" "))
			continue
		}

		w.Write([]byte("="))

		w.Write([]byte("\"" + fmt.Sprintf("%v", v) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}
	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</mark>")); err != nil {
		return err
	}

	return nil
}
