package source

import (
	"io"
	"text/template"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"

	"github.com/derekmwright/htemel/internal/generators/spec"
)

type ImportSet map[string]struct{}

func (is ImportSet) Add(i string) ImportSet {
	if _, ok := is[i]; !ok {
		is[i] = struct{}{}
	}
	return is
}

func (is ImportSet) Merge(other ImportSet) {
	for k := range other {
		is.Add(k)
	}
}

type TemplateFunc func() (*template.Template, ImportSet)

var titleCase = func(s string) string {
	return cases.Title(language.English).String(s)
}

func SourceHeader(w io.Writer, pkg string, e *spec.Element, children ...TemplateFunc) error {
	var (
		colTmpls   []*template.Template
		colImports = make(ImportSet)
	)

	colImports.Add("github.com/derekmwright/htemel")

	for _, child := range children {
		t, imps := child()
		colTmpls = append(colTmpls, t)
		colImports.Merge(imps)
	}

	tmpl := template.Must(template.New("Header").
		Funcs(template.FuncMap{
			"titleCase": titleCase,
		}).
		Parse(`// Code generated by htemel. DO NOT EDIT.
package {{ .PackageName }}

import (
{{ range $key, $value := .Imports }}  "{{ $key }}"
{{ end -}}
)
`))

	if err := tmpl.Execute(w, struct {
		PackageName string
		Imports     ImportSet
		Element     *spec.Element
	}{
		PackageName: pkg,
		Imports:     colImports,
		Element:     e,
	}); err != nil {
		return err
	}

	for _, t := range colTmpls {
		if err := t.Execute(w, e); err != nil {
			return err
		}
	}

	return nil
}

func BaseStruct() (*template.Template, ImportSet) {
	tmpl := template.Must(template.New("Struct").
		Funcs(template.FuncMap{
			"titleCase": titleCase,
		}).
		Parse(`
type {{ .Tag | titleCase }}Element struct {
	attributes {{ .Tag }}Attrs
	{{ if not .Void }}children []htemel.Node{{ end }}
	skipRender bool
}
`))

	return tmpl, nil
}

func BaseFunc() (*template.Template, ImportSet) {
	tmpl := template.Must(template.New("BaseFunc").
		Funcs(template.FuncMap{
			"titleCase": titleCase,
		}).Parse(`
// {{ .Tag | titleCase }} creates a tag <{{ .Tag }}> instance and returns it for further modification.
// Any children passed will be nested within the tag.
//
// Spec Description: {{ .Description }}
func {{ .Tag | titleCase }}({{ if not .Void }}children ...htemel.Node{{ end }}) *{{ .Tag | titleCase }}Element {
	node := &{{ .Tag | titleCase }}Element{
		children: children,
		attributes: make({{ .Tag }}Attrs),
	}

	return node
}
`))

	return tmpl, nil
}

func BaseCondFunc() (*template.Template, ImportSet) {
	tmpl := template.Must(template.New("BaseCondFunc").
		Funcs(template.FuncMap{
			"titleCase": titleCase,
		}).Parse(`
func {{ .Tag | titleCase }}If(condition bool{{ if not .Void }}, children ...htemel.Node{{ end }}) *{{ .Tag | titleCase }}Element {
	if condition {
		return {{ .Tag | titleCase }}(children...)
	}

	return &{{ .Tag | titleCase }}Element{
		skipRender: true,
	}
}
`))

	return tmpl, nil
}

func RenderFunc() (*template.Template, ImportSet) {
	tmpl := template.Must(template.New("RenderFunc").
		Funcs(template.FuncMap{
			"titleCase": titleCase,
		}).
		Parse(`
func (e *{{ .Tag | titleCase }}Element) Render(w io.Writer) error {
	if e.skipRender {
		return nil
	}

	if _, err := w.Write([]byte("<{{ .Tag }}")); err != nil {
		return err
	}

	c := len(e.attributes)
	i := 1
	for key, v := range e.attributes {
		if i == 1 {
			w.Write([]byte(" "))
		}

		w.Write([]byte(key + "="))
		w.Write([]byte("\"" + html.EscapeString(fmt.Sprintf("%v", v)) + "\""))

		if i < c {
			w.Write([]byte(" "))
		}

		i++
	}

	if _, err := w.Write([]byte(">")); err != nil {
		return err
	}

	for _, child := range e.children {
		if err := child.Render(w); err != nil {
			return err
		}
	}

	if _, err := w.Write([]byte("</{{ .Tag }}>")); err != nil {
		return err
	}

	return nil
}
`))

	is := ImportSet{}

	return tmpl, is.Add("io").Add("fmt").Add("golang.org/x/net/html")
}
